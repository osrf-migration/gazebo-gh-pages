{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/1740/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/1740.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1740/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/1740/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/1740/race-condition-when-deleting-contactsensor"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1740/vote"}}, "reporter": {"display_name": "Elte Hupkes", "uuid": "{f23aa1a9-ae57-493f-8169-fbb59b3eae43}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bf23aa1a9-ae57-493f-8169-fbb59b3eae43%7D"}, "html": {"href": "https://bitbucket.org/%7Bf23aa1a9-ae57-493f-8169-fbb59b3eae43%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/8560ee94d50ba277c411499a45b3d732d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsEH-5.png"}}, "nickname": "ElteHupkes", "type": "user", "account_id": "557058:b758f523-bdaa-4718-964c-03b825bdea8d"}, "title": "Race condition when deleting `ContactSensor`", "component": {"name": "physics", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/122876.json"}}}, "votes": 0, "watches": 2, "content": {"raw": "There is a race condition that might lead Gazebo to crash with a boost null pointer exception when deleting a model that contains a contact sensor. This is what happens:\r\n\r\n- When the model is removed, `Link::Fini()` is called for all its links, which calls `sensors::remove_sensor()` for all sensors scheduling them to be removed by the sensor thread.\r\n- When removing the contact sensor, the sensor thread calls `ContactSensor::Fini()`. This finalizer attempts to unregister its collision filter, for which it requires the scoped name of its parent. It retrieves this using `this->world->GetEntity(this->parentName)->GetScopedName()`. At this point however, the parent link is no longer known to the world (since it has already been deleted) and `this->world->GetEntity(this->parentName)` is null, crashing Gazebo.\r\n\r\nIf the sensor thread performs its removal code before the world thread removes the model, the problem might not manifest itself. From my experience you might not run into this when using the GUI, though using `gzserver` only it pretty much happens all the time. The workaround is simple: store the filter name with the class when the contact sensor is created, such that it need not be calculated again. I have attached a patch file that does just that.", "markup": "markdown", "html": "<p>There is a race condition that might lead Gazebo to crash with a boost null pointer exception when deleting a model that contains a contact sensor. This is what happens:</p>\n<ul>\n<li>When the model is removed, <code>Link::Fini()</code> is called for all its links, which calls <code>sensors::remove_sensor()</code> for all sensors scheduling them to be removed by the sensor thread.</li>\n<li>When removing the contact sensor, the sensor thread calls <code>ContactSensor::Fini()</code>. This finalizer attempts to unregister its collision filter, for which it requires the scoped name of its parent. It retrieves this using <code>this-&gt;world-&gt;GetEntity(this-&gt;parentName)-&gt;GetScopedName()</code>. At this point however, the parent link is no longer known to the world (since it has already been deleted) and <code>this-&gt;world-&gt;GetEntity(this-&gt;parentName)</code> is null, crashing Gazebo.</li>\n</ul>\n<p>If the sensor thread performs its removal code before the world thread removes the model, the problem might not manifest itself. From my experience you might not run into this when using the GUI, though using <code>gzserver</code> only it pretty much happens all the time. The workaround is simple: store the filter name with the class when the contact sensor is created, such that it need not be calculated again. I have attached a patch file that does just that.</p>", "type": "rendered"}, "assignee": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "state": "new", "version": {"name": "6.0", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/170782.json"}}}, "edited_on": null, "created_on": "2015-09-15T13:24:48.299345+00:00", "milestone": null, "updated_on": "2016-04-26T21:48:05.470193+00:00", "type": "issue", "id": 1740}