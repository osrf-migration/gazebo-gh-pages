{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1748/comments/28050543.json"}, "html": {"href": "#!/osrf/gazebo/issues/1748#comment-28050543"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1748.json"}}, "type": "issue", "id": 1748, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Significant sensor data timestamp accuracy regression from Gazebo2 to Gazebo4"}, "content": {"raw": "I looked into this a little and started by writing a test in the [camera_sensor_timestamp](#!/osrf/gazebo/branches/compare/camera_sensor_timestamp%0Ddefault#diff) branch. The test moves a tall thin box horizontally across the view of the camera, analytically calculates the box position in the image over time, and compare them with the actual camera images.\n\nUnfortunately I have not been able to reproduce the case where the camera sensor generates images with incorrect timestamp yet. The test currently passes. I played with a few different variables, e.g. box movement speed, image resolution and camera framerate, and it seems like the position of the box in the camera sensor images is always within 1-2 pixels of the one computed by hand.\n\nHere is my understanding of the camera sensor implementation in gazebo which influenced the expectations I wrote in the test:\n\n* physics and rendering threads are not synchronized so camera image timestamps do not always match the timestamps of other sensors that rely on the physics engine (e.g. imu, ray, force_torque, etc). The timestamps of camera image are typically some iterations behind.\n\n* for machines with less powerful gpu, camera sensors are not guaranteed to hit the target framerate.\n\n* camera sensors are allowed to \"catch-up\" if they missed the update deadline, meaning they can occasionally perform more updates in short intervals in order to meet the target framerate. \n\nI'll keep trying. If people have ideas on how the test can be improved, let me know too.\n", "markup": "markdown", "html": "<p>I looked into this a little and started by writing a test in the <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/branches/compare/camera_sensor_timestamp%0Ddefault#diff\" rel=\"nofollow\">camera_sensor_timestamp</a> branch. The test moves a tall thin box horizontally across the view of the camera, analytically calculates the box position in the image over time, and compare them with the actual camera images.</p>\n<p>Unfortunately I have not been able to reproduce the case where the camera sensor generates images with incorrect timestamp yet. The test currently passes. I played with a few different variables, e.g. box movement speed, image resolution and camera framerate, and it seems like the position of the box in the camera sensor images is always within 1-2 pixels of the one computed by hand.</p>\n<p>Here is my understanding of the camera sensor implementation in gazebo which influenced the expectations I wrote in the test:</p>\n<ul>\n<li>\n<p>physics and rendering threads are not synchronized so camera image timestamps do not always match the timestamps of other sensors that rely on the physics engine (e.g. imu, ray, force_torque, etc). The timestamps of camera image are typically some iterations behind.</p>\n</li>\n<li>\n<p>for machines with less powerful gpu, camera sensors are not guaranteed to hit the target framerate.</p>\n</li>\n<li>\n<p>camera sensors are allowed to \"catch-up\" if they missed the update deadline, meaning they can occasionally perform more updates in short intervals in order to meet the target framerate. </p>\n</li>\n</ul>\n<p>I'll keep trying. If people have ideas on how the test can be improved, let me know too.</p>", "type": "rendered"}, "created_on": "2016-05-25T18:15:23.475872+00:00", "user": {"display_name": "Ian Chen", "uuid": "{eaa6fca5-6deb-43f6-907f-971c144735dd}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D"}, "html": {"href": "https://bitbucket.org/%7Beaa6fca5-6deb-43f6-907f-971c144735dd%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5/1e4adcdf-1946-4280-9aea-eb5f15a7f912/128"}}, "nickname": "Ian Chen", "type": "user", "account_id": "557058:10b01d41-a2e9-4a41-a907-e6e2f03b6cd5"}, "updated_on": null, "type": "issue_comment", "id": 28050543}