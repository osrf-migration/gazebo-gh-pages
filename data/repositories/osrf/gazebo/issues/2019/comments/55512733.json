{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/2019/comments/55512733.json"}, "html": {"href": "#!/osrf/gazebo/issues/2019#comment-55512733"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/2019.json"}}, "type": "issue", "id": 2019, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Flaky seg-fault during teardown in transport::IOManager"}, "content": {"raw": "The backtrace points to the `thread->join()` call in `IOManager::Stop` at [IOManager.cc:53](#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/IOManager.cc#lines-53).\n\nThe `Connection` class [holds a static pointer to an IOManager object](#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/Connection.hh#lines-440). If any `Connection` notices the `IOManager` pointer is `NULL`, it [re-creates it in the Connection constructor](#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/Connection.cc#lines-93:94). The `IOManager` object stores a [reference count](#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/IOManager.cc#lines-65:81), and [~Connection deletes the IOManager object if it was the last connection using it](#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/Connection.cc#lines-125:136).\n\nSo it seems like `Connection` is essentially holding a shared pointer to a `static IOManager`. I don't see any mutexes or synchronization primitives used. I tried changing the `IOManager` count to a `std::atomic_int`, but that didn't solve it.\n\n~~~\ndiff -r 7e231471ab8e gazebo/transport/IOManager.hh\n--- a/gazebo/transport/IOManager.hh     Thu Jan 02 21:10:25 2020 -0800\n+++ b/gazebo/transport/IOManager.hh     Thu Jan 02 22:22:48 2020 -0800\n@@ -17,6 +17,7 @@\n #ifndef _IOMANAGER_HH_\n #define _IOMANAGER_HH_\n \n+#include <atomic>\n #include <boost/thread/thread.hpp>\n #include <boost/asio.hpp>\n #include \"gazebo/util/system.hh\"\n@@ -58,7 +60,7 @@\n \n       // Use io_service::work to keep the io_service running in thread\n       private: boost::asio::io_service::work *work;\n-      private: unsigned int count;\n+      private: std::atomic_int count;\n \n       private: boost::thread *thread;\n     };\n~~~\n\nI guess the `IOManager` could still get recreated if a new `Connection` was constructed while the last one was being deleted?", "markup": "markdown", "html": "<p>The backtrace points to the <code>thread-&gt;join()</code> call in <code>IOManager::Stop</code> at <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/IOManager.cc#lines-53\" rel=\"nofollow\">IOManager.cc:53</a>.</p>\n<p>The <code>Connection</code> class <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/Connection.hh#lines-440\" rel=\"nofollow\">holds a static pointer to an IOManager object</a>. If any <code>Connection</code> notices the <code>IOManager</code> pointer is <code>NULL</code>, it <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/Connection.cc#lines-93:94\" rel=\"nofollow\">re-creates it in the Connection constructor</a>. The <code>IOManager</code> object stores a <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/IOManager.cc#lines-65:81\" rel=\"nofollow\">reference count</a>, and <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/4c0591897f59a777fe5c0bf89d1bede4c7f66f21/gazebo/transport/Connection.cc#lines-125:136\" rel=\"nofollow\">~Connection deletes the IOManager object if it was the last connection using it</a>.</p>\n<p>So it seems like <code>Connection</code> is essentially holding a shared pointer to a <code>static IOManager</code>. I don't see any mutexes or synchronization primitives used. I tried changing the <code>IOManager</code> count to a <code>std::atomic_int</code>, but that didn't solve it.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"gh\">diff -r 7e231471ab8e gazebo/transport/IOManager.hh</span>\n<span class=\"gd\">--- a/gazebo/transport/IOManager.hh     Thu Jan 02 21:10:25 2020 -0800</span>\n<span class=\"gi\">+++ b/gazebo/transport/IOManager.hh     Thu Jan 02 22:22:48 2020 -0800</span>\n<span class=\"gu\">@@ -17,6 +17,7 @@</span>\n #ifndef _IOMANAGER_HH_\n #define _IOMANAGER_HH_\n\n<span class=\"gi\">+#include &lt;atomic&gt;</span>\n #include &lt;boost/thread/thread.hpp&gt;\n #include &lt;boost/asio.hpp&gt;\n #include &quot;gazebo/util/system.hh&quot;\n<span class=\"gu\">@@ -58,7 +60,7 @@</span>\n\n       // Use io_service::work to keep the io_service running in thread\n       private: boost::asio::io_service::work *work;\n<span class=\"gd\">-      private: unsigned int count;</span>\n<span class=\"gi\">+      private: std::atomic_int count;</span>\n\n       private: boost::thread *thread;\n     };\n</pre></div>\n\n\n<p>I guess the <code>IOManager</code> could still get recreated if a new <code>Connection</code> was constructed while the last one was being deleted?</p>", "type": "rendered"}, "created_on": "2020-01-03T06:37:12.723847+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": null, "type": "issue_comment", "id": 55512733}