{"priority": "major", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/1157/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/1157.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1157/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/1157/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/1157/gpuraysensor-support-for-intensity"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1157/vote"}}, "reporter": {"display_name": "Daniel Meltz", "uuid": "{af679193-4aee-48dc-9168-0d79021095b4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Baf679193-4aee-48dc-9168-0d79021095b4%7D"}, "html": {"href": "https://bitbucket.org/%7Baf679193-4aee-48dc-9168-0d79021095b4%7D/"}, "avatar": {"href": "https://bitbucket.org/account/dmeltz/avatar/"}}, "nickname": "dmeltz", "type": "user", "account_id": null}, "title": "GpuRaySensor support for intensity readings", "component": {"name": "sensors", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/122877.json"}}}, "votes": 1, "watches": 2, "content": {"raw": "The GPU ray sensor uses a shader to compute range readings (instead of the collision detection mechanism which is used by the regular CPU ray sensor).\r\nThis means that the GPU ray sensor does not know what collision shape produced the range reading, and cannot get an intensity reading. the GpuRaySensor::GetRetro functions returens 0.0  \r\n\r\n```\r\n#!c++\r\ndouble GpuRaySensor::GetRetro (int /*_index*/) const\r\n{\r\n  return 0.0;\r\n}\r\n```\r\n\r\nNate Koenig suggested (in his answer to my question in the mailing list) to get the collision shapes using a selection buffer technique.", "markup": "markdown", "html": "<p>The GPU ray sensor uses a shader to compute range readings (instead of the collision detection mechanism which is used by the regular CPU ray sensor).\nThis means that the GPU ray sensor does not know what collision shape produced the range reading, and cannot get an intensity reading. the GpuRaySensor::GetRetro functions returens 0.0  </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"kt\">double</span> <span class=\"n\">GpuRaySensor</span><span class=\"o\">::</span><span class=\"n\">GetRetro</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"cm\">/*_index*/</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"mf\">0.0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>Nate Koenig suggested (in his answer to my question in the mailing list) to get the collision shapes using a selection buffer technique.</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": {"name": "3.0", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/100247.json"}}}, "edited_on": null, "created_on": "2014-04-09T11:26:16.914441+00:00", "milestone": null, "updated_on": "2014-04-09T11:27:13.193907+00:00", "type": "issue", "id": 1157}