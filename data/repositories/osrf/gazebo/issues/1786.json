{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/1786/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/1786.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1786/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/1786/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/1786/invalid-access-of-base-children-results-in"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1786/vote"}}, "reporter": {"display_name": "Elte Hupkes", "uuid": "{f23aa1a9-ae57-493f-8169-fbb59b3eae43}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bf23aa1a9-ae57-493f-8169-fbb59b3eae43%7D"}, "html": {"href": "https://bitbucket.org/%7Bf23aa1a9-ae57-493f-8169-fbb59b3eae43%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/8560ee94d50ba277c411499a45b3d732d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsEH-5.png"}}, "nickname": "ElteHupkes", "type": "user", "account_id": "557058:b758f523-bdaa-4718-964c-03b825bdea8d"}, "title": "Invalid access of `Base::children` results in memory leak / undefined behavior", "component": {"name": "physics", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/122876.json"}}}, "votes": 0, "watches": 2, "content": {"raw": "Consider the following scenario:\r\n\r\n- `Base::Fini()` is called on an element with two children, calling `this->children.clear()`\r\n- Step by step, the call to `clear` first causes `this->children[0].use_count()` to become zero, so the first child is being garbage collected.\r\n- For this first child, `Base::~Base()` is called, which as a first step calls `Base::>RemoveChild(id)` on its parent (the original element)\r\n- `Base::RemoveChild(id)` iterates the list of children and modifies it, all of this *while* this list is being `clear`ed.\r\n\r\nThis concurrent read / write of a `std::vector` results in undefined behavior. If I follow the process in a debugger, when `RemoveChild` is called `children` consists of to `BasePtr`s, the first of which has at that point a use count of 0 (which makes sense since the element it points to is in its constructor). This element is shifted of `children` by `RemoveChild` because the ID matches, after which the list is now only 1 item long. What happens next is guesswork because it involves the internals of `std::vector`, but I believe that the `clear` procedure continues with the second item in the list (which is no longer there), leaving the use count of the first item at 1, so the original second child is never cleared. Depending on the implementation I reckon one might also expect a segmentation fault.\r\n\r\nSuggested fix: remove the call to `parent_->RemoveChild()` in `Base::~Base()`. The call doesn't make sense, because it implies that the parent still holds a reference to the child while it is in its destructor. This is of course nonsense, because if it did, the destructor would never have been called. If this call had to reside anywhere, I'd put it in `Base::Fini()`, but that would in the current scenario also result in a concurrent modification. I know of no places where a child is removed without involving its parent, so simply removing the call seems best.", "markup": "markdown", "html": "<p>Consider the following scenario:</p>\n<ul>\n<li><code>Base::Fini()</code> is called on an element with two children, calling <code>this-&gt;children.clear()</code></li>\n<li>Step by step, the call to <code>clear</code> first causes <code>this-&gt;children[0].use_count()</code> to become zero, so the first child is being garbage collected.</li>\n<li>For this first child, <code>Base::~Base()</code> is called, which as a first step calls <code>Base::&gt;RemoveChild(id)</code> on its parent (the original element)</li>\n<li><code>Base::RemoveChild(id)</code> iterates the list of children and modifies it, all of this <em>while</em> this list is being <code>clear</code>ed.</li>\n</ul>\n<p>This concurrent read / write of a <code>std::vector</code> results in undefined behavior. If I follow the process in a debugger, when <code>RemoveChild</code> is called <code>children</code> consists of to <code>BasePtr</code>s, the first of which has at that point a use count of 0 (which makes sense since the element it points to is in its constructor). This element is shifted of <code>children</code> by <code>RemoveChild</code> because the ID matches, after which the list is now only 1 item long. What happens next is guesswork because it involves the internals of <code>std::vector</code>, but I believe that the <code>clear</code> procedure continues with the second item in the list (which is no longer there), leaving the use count of the first item at 1, so the original second child is never cleared. Depending on the implementation I reckon one might also expect a segmentation fault.</p>\n<p>Suggested fix: remove the call to <code>parent_-&gt;RemoveChild()</code> in <code>Base::~Base()</code>. The call doesn't make sense, because it implies that the parent still holds a reference to the child while it is in its destructor. This is of course nonsense, because if it did, the destructor would never have been called. If this call had to reside anywhere, I'd put it in <code>Base::Fini()</code>, but that would in the current scenario also result in a concurrent modification. I know of no places where a child is removed without involving its parent, so simply removing the call seems best.</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": {"name": "6.0", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/170782.json"}}}, "edited_on": null, "created_on": "2015-11-25T10:34:41.809411+00:00", "milestone": null, "updated_on": "2015-12-01T12:01:37.128192+00:00", "type": "issue", "id": 1786}