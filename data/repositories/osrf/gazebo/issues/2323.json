{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/2323/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/2323.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/2323/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/2323/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/2323/depthcamera-connectnewrgbpointcloud"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/2323/vote"}}, "reporter": {"display_name": "Andrew Symington", "uuid": "{db1311fc-02e6-442e-84a1-4bb85dfee5ba}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bdb1311fc-02e6-442e-84a1-4bb85dfee5ba%7D"}, "html": {"href": "https://bitbucket.org/%7Bdb1311fc-02e6-442e-84a1-4bb85dfee5ba%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:cab3b56e-7c24-487c-b07f-05e0600adf54/8a009f21-29b8-4d43-98ed-2677428e17ff/128"}}, "nickname": "asymingt", "type": "user", "account_id": "557058:cab3b56e-7c24-487c-b07f-05e0600adf54"}, "title": "DepthCamera::ConnectNewRGBPointCloud() produces malformed point clouds", "component": {"name": "rendering", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/122881.json"}}}, "votes": 0, "watches": 1, "content": {"raw": "I profiled a plugin that used the gazebo_ros_pkgs \"kinect plugin\" for the gazebo depth sensor, and saw that about 6% of cycles were spent in the atan2() function projecting the depth image to a point cloud. So, I started looking at ways to reduce this computational overhead, since my project requires 4 depth cameras.\r\n\r\nI am using the ```DepthCamera::ConnectNewRGBPointCloud()``` connection to receive new callbacks with point cloud data. I am aware of the fact that the RGB data might be [problematic](#!/osrf/gazebo/issues/1865/rendering-depthcamera-does-not-output), but I don't mind because I only need occupancy. Looking at the Gazebo source code, I worked out that I needed to add the following block to the ```<camera>``` tag of my sensor in order for the depth camera to start pushing data:\r\n\r\n```\r\n#!xml\r\n<sensor name=\"haz_cam\" type=\"depth\">\r\n  <pose>0 0 0 0 0 0</pose>\r\n  <always_on>1</always_on>\r\n  <update_rate>5</update_rate>\r\n  <visualize>0</visualize>\r\n  <camera>\r\n    <horizontal_fov>1.0821</horizontal_fov> <!-- 62 degrees -->\r\n    <image>\r\n      <width>224</width>\r\n      <height>171</height>\r\n      <format>L8</format>\r\n    </image>\r\n    <clip>\r\n      <near>0.1</near>\r\n      <far>4</far>\r\n    </clip>\r\n    <depth_camera>\r\n      <output>points</output>\r\n    </depth_camera>\r\n  </camera>\r\n  <plugin name=\"haz_cam_ros\" filename=\"libgazebo_sensor_plugin_haz_cam.so\" />\r\n</sensor>\r\n```\r\nI have written a Sensor Plugin, which essentially converts the point cloud to a ROS ```sensor_msgs::PointCloud2``` message. The pipeline seems to work correctly and I can visualize the data in rviz. However, the data itself is wrong.  I assume that callback data  is striped into blocks of float[4] ={X, Y, Z, RGB}. However, when I try to pack it this way into the ROS message, I get a very weird / distorted point cloud in rviz (see image attached). \r\n\r\nHere is my plugin code. ```RosSensorPlugin``` is a thin abstract class that inherits from and intercepts the ```SensorPlugin::Load``` callback, creates a ROS NodeHandle, and passes it to the plugin. It's just a way of avoiding having to repeat ROS initialization boilerplate code.\r\n\r\n```\r\n#!c++\r\n\r\n// ROS includes\r\n#include <ros/ros.h>\r\n\r\n// Sensor plugin interface\r\n#include <ros_sensor_plugin/ros_sensor_plugin.h>\r\n\r\n// IMU Sensor message\r\n#include <sensor_msgs/PointCloud2.h>\r\n#include <sensor_msgs/point_cloud2_iterator.h>\r\n\r\n// STL includes\r\n#include <string>\r\n\r\nnamespace gazebo {\r\nclass GazeboSensorPluginHazCam : public RosSensorPlugin {\r\n public:\r\n  GazeboSensorPluginHazCam() : RosSensorPlugin(\"haz_cam\") {}\r\n\r\n  ~GazeboSensorPluginHazCam() {}\r\n\r\n protected:\r\n  // Called when plugin is loaded into gazebo\r\n  void LoadCallback(ros::NodeHandle *nh, sensors::SensorPtr sensor, sdf::ElementPtr sdf) {\r\n    // Get a link to the parent sensor\r\n    sensor_ = std::dynamic_pointer_cast < sensors::DepthCameraSensor > (sensor);\r\n    if (!sensor_) {\r\n      gzerr << \"GazeboSensorPluginHazCam requires a camera sensor as a parent.\\n\";\r\n      return;\r\n    }\r\n    // Create a publisher for the point cloud\r\n    point_cloud_pub_ = nh->advertise<sensor_msgs::PointCloud2>(\"/points\", 1,\r\n      boost::bind(&GazeboSensorPluginHazCam::ToggleCallback, this),\r\n      boost::bind(&GazeboSensorPluginHazCam::ToggleCallback, this));\r\n    // Basic header information\r\n    point_cloud_msg_.header.frame_id = GetFrame();  // Grabs the \r\n    point_cloud_msg_.is_bigendian = false;\r\n    point_cloud_msg_.point_step = sizeof(float) * 4;\r\n    // Declare the striped memory layout\r\n    sensor_msgs::PointField field;\r\n    field.name = \"x\";\r\n    field.offset = 0 * sizeof(float);\r\n    field.datatype = sensor_msgs::PointField::FLOAT32;\r\n    field.count = sizeof(float);\r\n    point_cloud_msg_.fields.push_back(field);\r\n    field.name = \"y\";\r\n    field.offset = 1 * sizeof(float);\r\n    field.datatype = sensor_msgs::PointField::FLOAT32;\r\n    field.count = sizeof(float);\r\n    point_cloud_msg_.fields.push_back(field);\r\n    field.name = \"z\";\r\n    field.offset = 2 * sizeof(float);\r\n    field.datatype = sensor_msgs::PointField::FLOAT32;\r\n    field.count = sizeof(float);\r\n    point_cloud_msg_.fields.push_back(field);\r\n    // Listen to the point cloud\r\n    update_ = sensor_->DepthCamera()->ConnectNewRGBPointCloud(\r\n      boost::bind(&GazeboSensorPluginHazCam::Callback, this, _1, _2, _3, _4, _5));\r\n  }\r\n\r\n  // Turn camera on or off based on topic subscription\r\n  void ToggleCallback() {\r\n    if (point_cloud_pub_.getNumSubscribers())\r\n      sensor_->SetActive(true);\r\n    else\r\n      sensor_->SetActive(false);\r\n  }\r\n \r\n  // this->dataPtr->depthBuffer, width, height, 1, \"FLOAT32\"\r\n  void Callback(const float *data, unsigned int width, unsigned height,\r\n    unsigned int len, const std::string & type) {\r\n    if (!sensor_->IsActive()) return;\r\n    gzmsg << \"Pointcloud callback!\\n\";\r\n    point_cloud_msg_.header.stamp = ros::Time::now();\r\n    point_cloud_msg_.width = width;\r\n    point_cloud_msg_.height = height;\r\n    point_cloud_msg_.row_step = point_cloud_msg_.width * point_cloud_msg_.point_step;\r\n    point_cloud_msg_.data.resize(point_cloud_msg_.row_step * point_cloud_msg_.height);\r\n    std::copy(\r\n      reinterpret_cast<const uint8_t*>(data),\r\n      reinterpret_cast<const uint8_t*>(data) + point_cloud_msg_.row_step * point_cloud_msg_.height,\r\n      point_cloud_msg_.data.begin());\r\n    point_cloud_pub_.publish(point_cloud_msg_);\r\n  }\r\n\r\n private:\r\n  // ROS variables\r\n  ros::Publisher point_cloud_pub_;\r\n  // Sensor pointer\r\n  sensors::DepthCameraSensorPtr sensor_;\r\n  // Camera and Point Cloud messages\r\n  sensor_msgs::PointCloud2 point_cloud_msg_;\r\n  // Gazebo variables\r\n  physics::WorldPtr world_;\r\n  physics::ModelPtr model_;\r\n  event::ConnectionPtr update_;\r\n  std::string frame_id_;\r\n};\r\n\r\nGZ_REGISTER_SENSOR_PLUGIN(GazeboSensorPluginHazCam)\r\n\r\n}   // namespace gazebo\r\n```", "markup": "markdown", "html": "<p>I profiled a plugin that used the gazebo_ros_pkgs \"kinect plugin\" for the gazebo depth sensor, and saw that about 6% of cycles were spent in the atan2() function projecting the depth image to a point cloud. So, I started looking at ways to reduce this computational overhead, since my project requires 4 depth cameras.</p>\n<p>I am using the <code>DepthCamera::ConnectNewRGBPointCloud()</code> connection to receive new callbacks with point cloud data. I am aware of the fact that the RGB data might be <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/issues/1865/rendering-depthcamera-does-not-output\" rel=\"nofollow\">problematic</a>, but I don't mind because I only need occupancy. Looking at the Gazebo source code, I worked out that I needed to add the following block to the <code>&lt;camera&gt;</code> tag of my sensor in order for the depth camera to start pushing data:</p>\n<div class=\"codehilite language-xml\"><pre><span></span><span class=\"nt\">&lt;sensor</span> <span class=\"na\">name=</span><span class=\"s\">&quot;haz_cam&quot;</span> <span class=\"na\">type=</span><span class=\"s\">&quot;depth&quot;</span><span class=\"nt\">&gt;</span>\n  <span class=\"nt\">&lt;pose&gt;</span>0 0 0 0 0 0<span class=\"nt\">&lt;/pose&gt;</span>\n  <span class=\"nt\">&lt;always_on&gt;</span>1<span class=\"nt\">&lt;/always_on&gt;</span>\n  <span class=\"nt\">&lt;update_rate&gt;</span>5<span class=\"nt\">&lt;/update_rate&gt;</span>\n  <span class=\"nt\">&lt;visualize&gt;</span>0<span class=\"nt\">&lt;/visualize&gt;</span>\n  <span class=\"nt\">&lt;camera&gt;</span>\n    <span class=\"nt\">&lt;horizontal_fov&gt;</span>1.0821<span class=\"nt\">&lt;/horizontal_fov&gt;</span> <span class=\"c\">&lt;!-- 62 degrees --&gt;</span>\n    <span class=\"nt\">&lt;image&gt;</span>\n      <span class=\"nt\">&lt;width&gt;</span>224<span class=\"nt\">&lt;/width&gt;</span>\n      <span class=\"nt\">&lt;height&gt;</span>171<span class=\"nt\">&lt;/height&gt;</span>\n      <span class=\"nt\">&lt;format&gt;</span>L8<span class=\"nt\">&lt;/format&gt;</span>\n    <span class=\"nt\">&lt;/image&gt;</span>\n    <span class=\"nt\">&lt;clip&gt;</span>\n      <span class=\"nt\">&lt;near&gt;</span>0.1<span class=\"nt\">&lt;/near&gt;</span>\n      <span class=\"nt\">&lt;far&gt;</span>4<span class=\"nt\">&lt;/far&gt;</span>\n    <span class=\"nt\">&lt;/clip&gt;</span>\n    <span class=\"nt\">&lt;depth_camera&gt;</span>\n      <span class=\"nt\">&lt;output&gt;</span>points<span class=\"nt\">&lt;/output&gt;</span>\n    <span class=\"nt\">&lt;/depth_camera&gt;</span>\n  <span class=\"nt\">&lt;/camera&gt;</span>\n  <span class=\"nt\">&lt;plugin</span> <span class=\"na\">name=</span><span class=\"s\">&quot;haz_cam_ros&quot;</span> <span class=\"na\">filename=</span><span class=\"s\">&quot;libgazebo_sensor_plugin_haz_cam.so&quot;</span> <span class=\"nt\">/&gt;</span>\n<span class=\"nt\">&lt;/sensor&gt;</span>\n</pre></div>\n\n\n<p>I have written a Sensor Plugin, which essentially converts the point cloud to a ROS <code>sensor_msgs::PointCloud2</code> message. The pipeline seems to work correctly and I can visualize the data in rviz. However, the data itself is wrong.  I assume that callback data  is striped into blocks of float[4] ={X, Y, Z, RGB}. However, when I try to pack it this way into the ROS message, I get a very weird / distorted point cloud in rviz (see image attached). </p>\n<p>Here is my plugin code. <code>RosSensorPlugin</code> is a thin abstract class that inherits from and intercepts the <code>SensorPlugin::Load</code> callback, creates a ROS NodeHandle, and passes it to the plugin. It's just a way of avoiding having to repeat ROS initialization boilerplate code.</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"c1\">// ROS includes</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;ros/ros.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"c1\">// Sensor plugin interface</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;ros_sensor_plugin/ros_sensor_plugin.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"c1\">// IMU Sensor message</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sensor_msgs/PointCloud2.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sensor_msgs/point_cloud2_iterator.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"c1\">// STL includes</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;string&gt;</span><span class=\"cp\"></span>\n\n<span class=\"k\">namespace</span> <span class=\"n\">gazebo</span> <span class=\"p\">{</span>\n<span class=\"k\">class</span> <span class=\"nc\">GazeboSensorPluginHazCam</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">RosSensorPlugin</span> <span class=\"p\">{</span>\n <span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"n\">GazeboSensorPluginHazCam</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">RosSensorPlugin</span><span class=\"p\">(</span><span class=\"s\">&quot;haz_cam&quot;</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n\n  <span class=\"o\">~</span><span class=\"n\">GazeboSensorPluginHazCam</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n\n <span class=\"k\">protected</span><span class=\"o\">:</span>\n  <span class=\"c1\">// Called when plugin is loaded into gazebo</span>\n  <span class=\"kt\">void</span> <span class=\"n\">LoadCallback</span><span class=\"p\">(</span><span class=\"n\">ros</span><span class=\"o\">::</span><span class=\"n\">NodeHandle</span> <span class=\"o\">*</span><span class=\"n\">nh</span><span class=\"p\">,</span> <span class=\"n\">sensors</span><span class=\"o\">::</span><span class=\"n\">SensorPtr</span> <span class=\"n\">sensor</span><span class=\"p\">,</span> <span class=\"n\">sdf</span><span class=\"o\">::</span><span class=\"n\">ElementPtr</span> <span class=\"n\">sdf</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Get a link to the parent sensor</span>\n    <span class=\"n\">sensor_</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">dynamic_pointer_cast</span> <span class=\"o\">&lt;</span> <span class=\"n\">sensors</span><span class=\"o\">::</span><span class=\"n\">DepthCameraSensor</span> <span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"n\">sensor</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">sensor_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">gzerr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;GazeboSensorPluginHazCam requires a camera sensor as a parent.</span><span class=\"se\">\\n</span><span class=\"s\">&quot;</span><span class=\"p\">;</span>\n      <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// Create a publisher for the point cloud</span>\n    <span class=\"n\">point_cloud_pub_</span> <span class=\"o\">=</span> <span class=\"n\">nh</span><span class=\"o\">-&gt;</span><span class=\"n\">advertise</span><span class=\"o\">&lt;</span><span class=\"n\">sensor_msgs</span><span class=\"o\">::</span><span class=\"n\">PointCloud2</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&quot;/points&quot;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n      <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">GazeboSensorPluginHazCam</span><span class=\"o\">::</span><span class=\"n\">ToggleCallback</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">),</span>\n      <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">GazeboSensorPluginHazCam</span><span class=\"o\">::</span><span class=\"n\">ToggleCallback</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">));</span>\n    <span class=\"c1\">// Basic header information</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">header</span><span class=\"p\">.</span><span class=\"n\">frame_id</span> <span class=\"o\">=</span> <span class=\"n\">GetFrame</span><span class=\"p\">();</span>  <span class=\"c1\">// Grabs the </span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">is_bigendian</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">point_step</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"c1\">// Declare the striped memory layout</span>\n    <span class=\"n\">sensor_msgs</span><span class=\"o\">::</span><span class=\"n\">PointField</span> <span class=\"n\">field</span><span class=\"p\">;</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">&quot;x&quot;</span><span class=\"p\">;</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"o\">*</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">);</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">datatype</span> <span class=\"o\">=</span> <span class=\"n\">sensor_msgs</span><span class=\"o\">::</span><span class=\"n\">PointField</span><span class=\"o\">::</span><span class=\"n\">FLOAT32</span><span class=\"p\">;</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">);</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">field</span><span class=\"p\">);</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">&quot;y&quot;</span><span class=\"p\">;</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">);</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">datatype</span> <span class=\"o\">=</span> <span class=\"n\">sensor_msgs</span><span class=\"o\">::</span><span class=\"n\">PointField</span><span class=\"o\">::</span><span class=\"n\">FLOAT32</span><span class=\"p\">;</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">);</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">field</span><span class=\"p\">);</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">&quot;z&quot;</span><span class=\"p\">;</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">);</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">datatype</span> <span class=\"o\">=</span> <span class=\"n\">sensor_msgs</span><span class=\"o\">::</span><span class=\"n\">PointField</span><span class=\"o\">::</span><span class=\"n\">FLOAT32</span><span class=\"p\">;</span>\n    <span class=\"n\">field</span><span class=\"p\">.</span><span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">);</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">fields</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">field</span><span class=\"p\">);</span>\n    <span class=\"c1\">// Listen to the point cloud</span>\n    <span class=\"n\">update_</span> <span class=\"o\">=</span> <span class=\"n\">sensor_</span><span class=\"o\">-&gt;</span><span class=\"n\">DepthCamera</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">ConnectNewRGBPointCloud</span><span class=\"p\">(</span>\n      <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">GazeboSensorPluginHazCam</span><span class=\"o\">::</span><span class=\"n\">Callback</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">_1</span><span class=\"p\">,</span> <span class=\"n\">_2</span><span class=\"p\">,</span> <span class=\"n\">_3</span><span class=\"p\">,</span> <span class=\"n\">_4</span><span class=\"p\">,</span> <span class=\"n\">_5</span><span class=\"p\">));</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// Turn camera on or off based on topic subscription</span>\n  <span class=\"kt\">void</span> <span class=\"n\">ToggleCallback</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">point_cloud_pub_</span><span class=\"p\">.</span><span class=\"n\">getNumSubscribers</span><span class=\"p\">())</span>\n      <span class=\"n\">sensor_</span><span class=\"o\">-&gt;</span><span class=\"n\">SetActive</span><span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">);</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">sensor_</span><span class=\"o\">-&gt;</span><span class=\"n\">SetActive</span><span class=\"p\">(</span><span class=\"nb\">false</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"c1\">// this-&gt;dataPtr-&gt;depthBuffer, width, height, 1, &quot;FLOAT32&quot;</span>\n  <span class=\"kt\">void</span> <span class=\"n\">Callback</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">float</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">width</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"n\">height</span><span class=\"p\">,</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">len</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span> <span class=\"n\">type</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">sensor_</span><span class=\"o\">-&gt;</span><span class=\"n\">IsActive</span><span class=\"p\">())</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"n\">gzmsg</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&quot;Pointcloud callback!</span><span class=\"se\">\\n</span><span class=\"s\">&quot;</span><span class=\"p\">;</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">header</span><span class=\"p\">.</span><span class=\"n\">stamp</span> <span class=\"o\">=</span> <span class=\"n\">ros</span><span class=\"o\">::</span><span class=\"n\">Time</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">width</span> <span class=\"o\">=</span> <span class=\"n\">width</span><span class=\"p\">;</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">height</span> <span class=\"o\">=</span> <span class=\"n\">height</span><span class=\"p\">;</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">row_step</span> <span class=\"o\">=</span> <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">width</span> <span class=\"o\">*</span> <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">point_step</span><span class=\"p\">;</span>\n    <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">resize</span><span class=\"p\">(</span><span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">row_step</span> <span class=\"o\">*</span> <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">height</span><span class=\"p\">);</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">copy</span><span class=\"p\">(</span>\n      <span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"k\">const</span> <span class=\"kt\">uint8_t</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">),</span>\n      <span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"k\">const</span> <span class=\"kt\">uint8_t</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">row_step</span> <span class=\"o\">*</span> <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">height</span><span class=\"p\">,</span>\n      <span class=\"n\">point_cloud_msg_</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">());</span>\n    <span class=\"n\">point_cloud_pub_</span><span class=\"p\">.</span><span class=\"n\">publish</span><span class=\"p\">(</span><span class=\"n\">point_cloud_msg_</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n <span class=\"k\">private</span><span class=\"o\">:</span>\n  <span class=\"c1\">// ROS variables</span>\n  <span class=\"n\">ros</span><span class=\"o\">::</span><span class=\"n\">Publisher</span> <span class=\"n\">point_cloud_pub_</span><span class=\"p\">;</span>\n  <span class=\"c1\">// Sensor pointer</span>\n  <span class=\"n\">sensors</span><span class=\"o\">::</span><span class=\"n\">DepthCameraSensorPtr</span> <span class=\"n\">sensor_</span><span class=\"p\">;</span>\n  <span class=\"c1\">// Camera and Point Cloud messages</span>\n  <span class=\"n\">sensor_msgs</span><span class=\"o\">::</span><span class=\"n\">PointCloud2</span> <span class=\"n\">point_cloud_msg_</span><span class=\"p\">;</span>\n  <span class=\"c1\">// Gazebo variables</span>\n  <span class=\"n\">physics</span><span class=\"o\">::</span><span class=\"n\">WorldPtr</span> <span class=\"n\">world_</span><span class=\"p\">;</span>\n  <span class=\"n\">physics</span><span class=\"o\">::</span><span class=\"n\">ModelPtr</span> <span class=\"n\">model_</span><span class=\"p\">;</span>\n  <span class=\"n\">event</span><span class=\"o\">::</span><span class=\"n\">ConnectionPtr</span> <span class=\"n\">update_</span><span class=\"p\">;</span>\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">frame_id_</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"n\">GZ_REGISTER_SENSOR_PLUGIN</span><span class=\"p\">(</span><span class=\"n\">GazeboSensorPluginHazCam</span><span class=\"p\">)</span>\n\n<span class=\"p\">}</span>   <span class=\"c1\">// namespace gazebo</span>\n</pre></div>", "type": "rendered"}, "assignee": null, "state": "resolved", "version": {"name": "7.0", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/242744.json"}}}, "edited_on": null, "created_on": "2017-08-05T06:59:44.382603+00:00", "milestone": null, "updated_on": "2017-08-30T21:03:02.158162+00:00", "type": "issue", "id": 2323}