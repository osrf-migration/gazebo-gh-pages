{"priority": "major", "kind": "proposal", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/1699/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/1699.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1699/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/1699/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/1699/create-a-standardized-way-for-plugins-to"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1699/vote"}}, "reporter": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}, "title": "Create a standardized way for plugins to expose their required parameters", "component": null, "votes": 0, "watches": 2, "content": {"raw": "Plugins can take parameters, but currently there's no standard way for them to expose which parameters they take.\r\n\r\nTake the [InitialVelocityPlugin](#!/osrf/gazebo/src/8e2e8aa73d30c560a298d94f721af62bf2f0a523/plugins/InitialVelocityPlugin.cc) for example, which is used in [this](#!/osrf/gazebo/src/8e2e8aa73d30c560a298d94f721af62bf2f0a523/worlds/initial_velocity.world) demo world. It can take `<linear>` and `<angular>` parameters and both are optional. But without looking into the source code, there's no way to know what parameters it can take.\r\n\r\nThe motivation for requesting this feature is to integrate plugins into the model editor in convenient ways. It would be nice to offer users a list of pre-existing plugins such as the initial velocity plugin and let users fill a form with parameters. But to offer the interface, the editor needs to know which parameters the plugin accepts.\r\n\r\nOne way I can think of doing this is having virtual set/get functions and those plugins which implement these get to be used in the editor. Something like: \r\n\r\n~~~\r\n/// \\brief Returns a map with this plugin's parameters key/value pairs.\r\npublic: virtual std::map<std::string, std::string> ModelPlugin::Params() const {}\r\n\r\n/// \\brief Set the value for parameter with the given key\r\n/// \\return True if successful\r\npublic: virtual bool ModelPlugin::SetParam(std::string _key, std::string _value) const {}\r\n~~~\r\n\r\nThis doesn't say if parameters are optional, required or repeated though, so probably some other structure makes more sense.\r\n", "markup": "markdown", "html": "<p>Plugins can take parameters, but currently there's no standard way for them to expose which parameters they take.</p>\n<p>Take the <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/8e2e8aa73d30c560a298d94f721af62bf2f0a523/plugins/InitialVelocityPlugin.cc\" rel=\"nofollow\">InitialVelocityPlugin</a> for example, which is used in <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/8e2e8aa73d30c560a298d94f721af62bf2f0a523/worlds/initial_velocity.world\" rel=\"nofollow\">this</a> demo world. It can take <code>&lt;linear&gt;</code> and <code>&lt;angular&gt;</code> parameters and both are optional. But without looking into the source code, there's no way to know what parameters it can take.</p>\n<p>The motivation for requesting this feature is to integrate plugins into the model editor in convenient ways. It would be nice to offer users a list of pre-existing plugins such as the initial velocity plugin and let users fill a form with parameters. But to offer the interface, the editor needs to know which parameters the plugin accepts.</p>\n<p>One way I can think of doing this is having virtual set/get functions and those plugins which implement these get to be used in the editor. Something like: </p>\n<div class=\"codehilite\"><pre><span></span>/// \\brief Returns a map with this plugin&#39;s parameters key/value pairs.\npublic: virtual std::map&lt;std::string, std::string&gt; ModelPlugin::Params() const {}\n\n/// \\brief Set the value for parameter with the given key\n/// \\return True if successful\npublic: virtual bool ModelPlugin::SetParam(std::string _key, std::string _value) const {}\n</pre></div>\n\n\n<p>This doesn't say if parameters are optional, required or repeated though, so probably some other structure makes more sense.</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": {"name": "all", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/225575.json"}}}, "edited_on": null, "created_on": "2015-08-10T21:13:52.271372+00:00", "milestone": null, "updated_on": "2016-09-14T19:23:22.812840+00:00", "type": "issue", "id": 1699}