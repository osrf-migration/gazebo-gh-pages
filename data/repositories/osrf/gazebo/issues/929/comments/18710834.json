{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/929/comments/18710834.json"}, "html": {"href": "#!/osrf/gazebo/issues/929#comment-18710834"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/929.json"}}, "type": "issue", "id": 929, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Consider using Eigen to improve math::Matrix classes"}, "content": {"raw": "# Note on subtraction operator for Pose object\n\n\n> Well that's definitely surprising that subtracting two poses in the same frame would give you a pose in a different frame.\n\nI thought graphically it made good sense; i.e. in @traversaro's representation defined in issue #216, we have\n\n`P_Transform_Q` = `O_Transform_Q` - `O_Transform_P`\n\nSince `P_Transform_Q` is a transform from frame `P` to frame `Q`, I thought it is most conveniently defined in reference frame `P` (the base frame). Using another detached frame as reference frame (such as `O`) would have required us to *teleport* the resulting transform to a different frame, obfuscating things graphically.\n\nAnd correspondingly gazebo pose math fashions `O_Transform_B` = `A_Transform_B` + `O_Transform_A` or equivalently `O_Transform_B` = `O_Transform_A`*`A_Transform_B`\n\nOn this note, we need to add tests on `operator*` in [Pose_TEST.cc](#!/osrf/gazebo/src/71e285f4b088b78854926ee58740f9f1595fc7f0/gazebo/math/Pose_TEST.cc?at=default).\n\nSemantically, it does seem the multiplication operator is easier to read than the addition operator.\n\n# UI Question:\n\n@jbohren,\n\nFor UI improvement, taking a closer look at the `gzmath_test` example, I am guessing:\n\n  1. `p_ref` defines a transform (translation followed by rotation) let's say from frame `O` to `P` defined in base frame `O`, and\n  1. `p_servo` defines a transform (translation followed by rotation), let's say from frame `O` to `Q` defined in base frame `O`.\n\nWhich frame do you expect `p_rel` to be defined in? For reference:\n\n~~~\n    gazebo::math::Pose p_rel = p_ref - p_servo;\n~~~\n\n\n# Moving to a new system\n\nHistorically, given the `math::Pose` object is a custom object created in Gazebo, I didn't think too much about modifying its meaning while creating documentation and unit tests for the operators.  The current *definition* was deduced by working backwards from code that was there.  If one follows the updated documentation and the unit tested operators, the results should be consistent and graphically concise.  But as suggested in this issue, current scheme's semantic meanings may be ill-designed. So when we do switch to something else, let's make sure code + documentation + unit tests are all clearly and unambiguously presented at the same time.\n\nSo lastly, if we are moving on to a new representation, for reference, I like IHMC's suggestion (similar to Ravelin implementation), explicitly embedding a reference frame in the transform object. Or maybe we should adopt one of these libraries.", "markup": "markdown", "html": "<h1 id=\"markdown-header-note-on-subtraction-operator-for-pose-object\">Note on subtraction operator for Pose object</h1>\n<blockquote>\n<p>Well that's definitely surprising that subtracting two poses in the same frame would give you a pose in a different frame.</p>\n</blockquote>\n<p>I thought graphically it made good sense; i.e. in @traversaro's representation defined in issue <a href=\"#!/osrf/gazebo/issues/216/pose-addition-and-subtraction-needs-work\" rel=\"nofollow\" title=\"Pose addition and subtraction needs work\" class=\"ap-connect-link\"><s>#216</s></a>, we have</p>\n<p><code>P_Transform_Q</code> = <code>O_Transform_Q</code> - <code>O_Transform_P</code></p>\n<p>Since <code>P_Transform_Q</code> is a transform from frame <code>P</code> to frame <code>Q</code>, I thought it is most conveniently defined in reference frame <code>P</code> (the base frame). Using another detached frame as reference frame (such as <code>O</code>) would have required us to <em>teleport</em> the resulting transform to a different frame, obfuscating things graphically.</p>\n<p>And correspondingly gazebo pose math fashions <code>O_Transform_B</code> = <code>A_Transform_B</code> + <code>O_Transform_A</code> or equivalently <code>O_Transform_B</code> = <code>O_Transform_A</code>*<code>A_Transform_B</code></p>\n<p>On this note, we need to add tests on <code>operator*</code> in <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/71e285f4b088b78854926ee58740f9f1595fc7f0/gazebo/math/Pose_TEST.cc?at=default\" rel=\"nofollow\">Pose_TEST.cc</a>.</p>\n<p>Semantically, it does seem the multiplication operator is easier to read than the addition operator.</p>\n<h1 id=\"markdown-header-ui-question\">UI Question:</h1>\n<p>@jbohren,</p>\n<p>For UI improvement, taking a closer look at the <code>gzmath_test</code> example, I am guessing:</p>\n<ol>\n<li><code>p_ref</code> defines a transform (translation followed by rotation) let's say from frame <code>O</code> to <code>P</code> defined in base frame <code>O</code>, and</li>\n<li><code>p_servo</code> defines a transform (translation followed by rotation), let's say from frame <code>O</code> to <code>Q</code> defined in base frame <code>O</code>.</li>\n</ol>\n<p>Which frame do you expect <code>p_rel</code> to be defined in? For reference:</p>\n<div class=\"codehilite\"><pre><span></span>    <span class=\"nt\">gazebo</span><span class=\"p\">::</span><span class=\"nd\">math</span><span class=\"p\">::</span><span class=\"nd\">Pose</span> <span class=\"nt\">p_rel</span> <span class=\"o\">=</span> <span class=\"nt\">p_ref</span> <span class=\"nt\">-</span> <span class=\"nt\">p_servo</span><span class=\"o\">;</span>\n</pre></div>\n\n\n<h1 id=\"markdown-header-moving-to-a-new-system\">Moving to a new system</h1>\n<p>Historically, given the <code>math::Pose</code> object is a custom object created in Gazebo, I didn't think too much about modifying its meaning while creating documentation and unit tests for the operators.  The current <em>definition</em> was deduced by working backwards from code that was there.  If one follows the updated documentation and the unit tested operators, the results should be consistent and graphically concise.  But as suggested in this issue, current scheme's semantic meanings may be ill-designed. So when we do switch to something else, let's make sure code + documentation + unit tests are all clearly and unambiguously presented at the same time.</p>\n<p>So lastly, if we are moving on to a new representation, for reference, I like IHMC's suggestion (similar to Ravelin implementation), explicitly embedding a reference frame in the transform object. Or maybe we should adopt one of these libraries.</p>", "type": "rendered"}, "created_on": "2015-06-10T00:27:54.754458+00:00", "user": {"display_name": "John Hsu", "uuid": "{0a186eae-abf0-4514-a951-23db5eccc286}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B0a186eae-abf0-4514-a951-23db5eccc286%7D"}, "html": {"href": "https://bitbucket.org/%7B0a186eae-abf0-4514-a951-23db5eccc286%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:f3968cd3-4910-4384-8349-482a6c7889ec/5445ce6e-6273-47f0-84eb-621c86ca11cb/128"}}, "nickname": "hsu", "type": "user", "account_id": "557058:f3968cd3-4910-4384-8349-482a6c7889ec"}, "updated_on": null, "type": "issue_comment", "id": 18710834}