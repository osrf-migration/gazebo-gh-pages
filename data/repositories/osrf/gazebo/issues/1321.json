{"priority": "minor", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/1321/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/1321.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1321/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/1321/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/1321/proper-joint-torque-feedback"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1321/vote"}}, "reporter": {"display_name": "Silvio Traversaro", "uuid": "{34f404cb-5642-4f27-a032-e04c7143d776}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B34f404cb-5642-4f27-a032-e04c7143d776%7D"}, "html": {"href": "https://bitbucket.org/%7B34f404cb-5642-4f27-a032-e04c7143d776%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:e1c3e6a0-9a64-4e5f-a668-feebc191c5b6/578caaa1-056c-45a2-8bf9-bee94c3bebef/128"}}, "nickname": "traversaro", "type": "user", "account_id": "557058:e1c3e6a0-9a64-4e5f-a668-feebc191c5b6"}, "title": "Proper joint torque feedback", "component": {"name": "physics", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/122876.json"}}}, "votes": 3, "watches": 8, "content": {"raw": "I have several questions regarding how to properly implement joint torque feedback in Gazebo. I don't know if the bug tracker is the right place to post this questions, but given that I will get in the internal details of Gazebo and this question could lead to some new physics-related test, I prefer to post here instead of posting in Gazebo Answers. To keep the discussion simple I will refer only to revolute joints, but the concepts can be generalized to other types of joints. I also disregard joint stiffness, mainly because I don't have a clear idea in my mind on how it is implemented in Gazebo. Sorry if I probably write obvious notions for stating my point, but I prefer to clearly define concepts as much as possible to avoid misunderstandings. \r\n\r\nAt this moment, Gazebo is not simulating any kind of motor dynamics, but it is simulating joint friction (currently only viscous friction model, with an additional Coulomb/dry friction tem is being implemented in [issue 381](#!/osrf/gazebo/issue/381/ode-joints-dont-support-friction-parameter) ). \r\n\r\nDisregarding torque limits, we can then define the torques applied by any controller as: \r\n\r\n * the *motor torque* (i.e. the the quantity setted by the `JointController` with the `Joint::SetForce()` method). \r\n\r\nThis *motor torque* is then equal to the difference (or addiction, depending on how you define the different components) between:\r\n\r\n * the *joint torque* (i.e. the torque that, for a 1-DOF fixed base robot with no gravity and no external force, we find on the left side of the dynamics equation `I \\ddot{q} = \\tau`) and\r\n\r\n * the *friction torque* (i.e. the torque opposing the motion due to friction).\r\n\r\n\r\nCurrently the joint torque feedback is implemented in `gazebo_ros_control` (and also in our `gazebo-yarp-plugins`) using the `Joint::GetForce()` method. This method, as far as I was able to test (the documentation says that it is not implemented, so I guess it is simply not updated), just returns the last value set through `Joint::SetForce()`. Using the notation used in this issue, this function returns the *motor torques*.  However, for proper force control, we are interested in *joint torque*. \r\n\r\nTo see why we want to control the *joint torques* let's take as an example a joint controlled with a classical impedance control scheme: `\\tau = K(q_m-q_d)`, where:\r\n\r\n \r\n * `\\tau` is the controlled torque (Nm)\r\n * `K` is the impedance stiffness (Nm/[rad])\r\n * `q_m` is the measured position of the joint ([rad])\r\n * `q_d` is the desired position of the joint ([rad])\r\n\r\nLet's imagine that a Coulomb friction of 1Nm is acting on the joint, and the impedance stiffness is set to 1 Nm/[rad]. If the controlled torque is the *motor torque*, we will have a *deadband* of 1 [rad] around the desired position, where no actual *joint torque* is exerted on the robot. This because in the deadband all the commanded torque are lower then 1 Nm, and so they are counterbalanced by the Coulomb *friction torque*. \r\n\r\nWhat usually happens in real robots is that an inner loop for controlling *joint torque* by commanding appropriate *motor torques*, using some kind of *joint torque* feedback (SEA springs, strain gauges, ...). At the best of my knowledge, there is no clean way to get *joint torques* in Gazebo. A possible solution that should work is to use the output of `Joint::GetForceTorque()` and to project it on the joint axis, but I still have to test it.\r\n\r\n Even if this works, do you think it could make sense to have a proper method for the `physics::Joint` class for returning *joint torques*?\r\n\r\n", "markup": "markdown", "html": "<p>I have several questions regarding how to properly implement joint torque feedback in Gazebo. I don't know if the bug tracker is the right place to post this questions, but given that I will get in the internal details of Gazebo and this question could lead to some new physics-related test, I prefer to post here instead of posting in Gazebo Answers. To keep the discussion simple I will refer only to revolute joints, but the concepts can be generalized to other types of joints. I also disregard joint stiffness, mainly because I don't have a clear idea in my mind on how it is implemented in Gazebo. Sorry if I probably write obvious notions for stating my point, but I prefer to clearly define concepts as much as possible to avoid misunderstandings. </p>\n<p>At this moment, Gazebo is not simulating any kind of motor dynamics, but it is simulating joint friction (currently only viscous friction model, with an additional Coulomb/dry friction tem is being implemented in <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/issue/381/ode-joints-dont-support-friction-parameter\" rel=\"nofollow\">issue 381</a> ). </p>\n<p>Disregarding torque limits, we can then define the torques applied by any controller as: </p>\n<ul>\n<li>the <em>motor torque</em> (i.e. the the quantity setted by the <code>JointController</code> with the <code>Joint::SetForce()</code> method). </li>\n</ul>\n<p>This <em>motor torque</em> is then equal to the difference (or addiction, depending on how you define the different components) between:</p>\n<ul>\n<li>\n<p>the <em>joint torque</em> (i.e. the torque that, for a 1-DOF fixed base robot with no gravity and no external force, we find on the left side of the dynamics equation <code>I \\ddot{q} = \\tau</code>) and</p>\n</li>\n<li>\n<p>the <em>friction torque</em> (i.e. the torque opposing the motion due to friction).</p>\n</li>\n</ul>\n<p>Currently the joint torque feedback is implemented in <code>gazebo_ros_control</code> (and also in our <code>gazebo-yarp-plugins</code>) using the <code>Joint::GetForce()</code> method. This method, as far as I was able to test (the documentation says that it is not implemented, so I guess it is simply not updated), just returns the last value set through <code>Joint::SetForce()</code>. Using the notation used in this issue, this function returns the <em>motor torques</em>.  However, for proper force control, we are interested in <em>joint torque</em>. </p>\n<p>To see why we want to control the <em>joint torques</em> let's take as an example a joint controlled with a classical impedance control scheme: <code>\\tau = K(q_m-q_d)</code>, where:</p>\n<ul>\n<li><code>\\tau</code> is the controlled torque (Nm)</li>\n<li><code>K</code> is the impedance stiffness (Nm/[rad])</li>\n<li><code>q_m</code> is the measured position of the joint ([rad])</li>\n<li><code>q_d</code> is the desired position of the joint ([rad])</li>\n</ul>\n<p>Let's imagine that a Coulomb friction of 1Nm is acting on the joint, and the impedance stiffness is set to 1 Nm/[rad]. If the controlled torque is the <em>motor torque</em>, we will have a <em>deadband</em> of 1 [rad] around the desired position, where no actual <em>joint torque</em> is exerted on the robot. This because in the deadband all the commanded torque are lower then 1 Nm, and so they are counterbalanced by the Coulomb <em>friction torque</em>. </p>\n<p>What usually happens in real robots is that an inner loop for controlling <em>joint torque</em> by commanding appropriate <em>motor torques</em>, using some kind of <em>joint torque</em> feedback (SEA springs, strain gauges, ...). At the best of my knowledge, there is no clean way to get <em>joint torques</em> in Gazebo. A possible solution that should work is to use the output of <code>Joint::GetForceTorque()</code> and to project it on the joint axis, but I still have to test it.</p>\n<p>Even if this works, do you think it could make sense to have a proper method for the <code>physics::Joint</code> class for returning <em>joint torques</em>?</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": {"name": "all", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/225575.json"}}}, "edited_on": null, "created_on": "2014-10-29T22:24:19.311631+00:00", "milestone": null, "updated_on": "2017-05-30T14:24:45.215226+00:00", "type": "issue", "id": 1321}