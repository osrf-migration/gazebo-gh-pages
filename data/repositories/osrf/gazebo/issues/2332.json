{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/2332/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/2332.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/2332/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/2332/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/2332/possible-race-condition-in-eventhh-causing"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/2332/vote"}}, "reporter": {"display_name": "J\u00f8rgen Nordmoen", "uuid": "{53155142-7a18-42b2-b368-bd692191b31f}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B53155142-7a18-42b2-b368-bd692191b31f%7D"}, "html": {"href": "https://bitbucket.org/%7B53155142-7a18-42b2-b368-bd692191b31f%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/e8b2ec664d74e45e16bb639df6c1f884d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJN-5.png"}}, "nickname": "jorgehn", "type": "user", "account_id": "557058:7650baa8-82ea-4be9-a15a-9ecf390c16b6"}, "title": "Possible race condition in Event.hh causing Segmentation Fault", "component": {"name": "common", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/138866.json"}}}, "votes": 3, "watches": 4, "content": {"raw": "This problem relates to [this question](http://answers.gazebosim.org/question/16397/roslaunch-gazebo-2-process-has-died-pid-7605-exit-code-139/) which basically boils down to Gazebo segfaulting.\r\n\r\nI have tried to debug the problem to the best of my abilities and have found that the problem occurs in `Event.hh`. See stack trace below:\r\n\r\n```bash\r\n(gdb) bt\r\n#0  std::atomic<bool>::operator bool (this=0x0) at /home/jorgehn/gazebo/gazebo/physics/World.cc:740\r\n#1  gazebo::event::EventT<void (gazebo::common::UpdateInfo const&)>::Signal<gazebo::common::UpdateInfo>(gazebo::common::UpdateInfo const&) (_p=..., this=<optimized out>)\r\n    at /home/jorgehn/gazebo/gazebo/common/Event.hh:381\r\n#2  gazebo::event::EventT<void (gazebo::common::UpdateInfo const&)>::operator()<gazebo::common::UpdateInfo>(gazebo::common::UpdateInfo const&) (_p=..., this=<optimized out>)\r\n    at /home/jorgehn/gazebo/gazebo/common/Event.hh:216\r\n#3  gazebo::physics::World::Update (this=this@entry=0xbd7950) at /home/jorgehn/gazebo/gazebo/physics/World.cc:740\r\n#4  0x00007ffff62bf6cf in gazebo::physics::World::Step (this=this@entry=0xbd7950) at /home/jorgehn/gazebo/gazebo/physics/World.cc:672\r\n#5  0x00007ffff62bfb45 in gazebo::physics::World::RunLoop (this=0xbd7950) at /home/jorgehn/gazebo/gazebo/physics/World.cc:481\r\n#6  0x00007ffff40745d5 in ?? () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.58.0\r\n#7  0x00007ffff65dd6ba in start_thread (arg=0x7fff6e3fa700) at pthread_create.c:333\r\n#8  0x00007ffff6be63dd in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109\r\n(gdb) whatis iter.second->on Attempt to take address of value not located in memory.\r\n```\r\nI do not know the cause of this null pointer, my suspicion is that I reset the world quite often which causes a race condition to eventually manifest in a null pointer dereference.\r\nThe reason I suspect this is that in the `EventT<T>::Cleanup` method of `Event.hh` there is a mutex. The mutex seems to be designed to protect, `connections`, but the mutex is not used in any other method. This lead me to believe that the race condition happens when `connections` is altered during world reset. To test this I put a `std::lock_guard` in every method in `Event.hh` and ran my program again. This time the race condition never happened (I ran the program for several hours). To semi verify I removed the `std::lock_guard` again and the program crashed within 20 minutes of running.\r\n\r\nThe mutex in `Event.hh` is present from Gazebo 7.0.0 (which is the version I first tried) and is still present on master in this repository. However, no other method in `EventT<T>` uses this mutex.\r\n\r\nBecause Gazebo is such a complicated and large software I have not been able to verify that this absolutely solves the problem. I hope someone more knowledgeable about Gazebo can take a look and see if the problem is realistic (could there ever be a race condition with `Signal`?) and how should the problem be solved (`std::lock_guard`s all over the place is error prone as demonstrated by this problem if that is indeed the problem).\r\n\r\nThe \"fix\" I tested is based on parent `28214:a29d8dabed9a gazebo7_7.0.0`:\r\n```bashof\r\ndiff -r a29d8dabed9a gazebo/common/Event.hh\r\n--- a/gazebo/common/Event.hh\tTue Jan 26 01:05:38 2016 +0100\r\n+++ b/gazebo/common/Event.hh\tThu Aug 17 10:49:33 2017 +0200\r\n@@ -358,6 +358,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -373,6 +374,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -389,6 +391,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -406,6 +409,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -425,6 +429,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -446,6 +451,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -468,6 +474,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -491,6 +498,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections.begin())\r\n         {\r\n@@ -516,6 +524,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -545,6 +554,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -576,6 +586,7 @@\r\n       {\r\n         this->Cleanup();\r\n \r\n+\tstd::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n         this->myDataPtr->signaled = true;\r\n         for (auto iter: this->myDataPtr->connections)\r\n         {\r\n@@ -616,6 +627,7 @@\r\n     template<typename T>\r\n     ConnectionPtr EventT<T>::Connect(const boost::function<T> &_subscriber)\r\n     {\r\n+      std::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n       int index = 0;\r\n       if (!this->myDataPtr->connections.empty())\r\n       {\r\n@@ -645,6 +657,7 @@\r\n     template<typename T>\r\n     unsigned int EventT<T>::ConnectionCount() const\r\n     {\r\n+      std::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n       return this->myDataPtr->connections.size();\r\n     }\r\n \r\n@@ -653,6 +666,7 @@\r\n     template<typename T>\r\n     void EventT<T>::Disconnect(int _id)\r\n     {\r\n+      std::lock_guard<std::mutex> lock(this->myDataPtr->mutex);\r\n       // Find the connection\r\n       auto const &it = this->myDataPtr->connections.find(_id);\r\n```\r\n\r\nI have not been able to test this on master or with Gazebo8 because of an [unrelated bug](https://github.com/ros-simulation/gazebo_ros_pkgs/issues/596) which stops my setup from running.", "markup": "markdown", "html": "<p>This problem relates to <a data-is-external-link=\"true\" href=\"http://answers.gazebosim.org/question/16397/roslaunch-gazebo-2-process-has-died-pid-7605-exit-code-139/\" rel=\"nofollow\">this question</a> which basically boils down to Gazebo segfaulting.</p>\n<p>I have tried to debug the problem to the best of my abilities and have found that the problem occurs in <code>Event.hh</code>. See stack trace below:</p>\n<div class=\"codehilite language-bash\"><pre><span></span><span class=\"o\">(</span>gdb<span class=\"o\">)</span> bt\n<span class=\"c1\">#0  std::atomic&lt;bool&gt;::operator bool (this=0x0) at /home/jorgehn/gazebo/gazebo/physics/World.cc:740</span>\n<span class=\"c1\">#1  gazebo::event::EventT&lt;void (gazebo::common::UpdateInfo const&amp;)&gt;::Signal&lt;gazebo::common::UpdateInfo&gt;(gazebo::common::UpdateInfo const&amp;) (_p=..., this=&lt;optimized out&gt;)</span>\n    at /home/jorgehn/gazebo/gazebo/common/Event.hh:381\n<span class=\"c1\">#2  gazebo::event::EventT&lt;void (gazebo::common::UpdateInfo const&amp;)&gt;::operator()&lt;gazebo::common::UpdateInfo&gt;(gazebo::common::UpdateInfo const&amp;) (_p=..., this=&lt;optimized out&gt;)</span>\n    at /home/jorgehn/gazebo/gazebo/common/Event.hh:216\n<span class=\"c1\">#3  gazebo::physics::World::Update (this=this@entry=0xbd7950) at /home/jorgehn/gazebo/gazebo/physics/World.cc:740</span>\n<span class=\"c1\">#4  0x00007ffff62bf6cf in gazebo::physics::World::Step (this=this@entry=0xbd7950) at /home/jorgehn/gazebo/gazebo/physics/World.cc:672</span>\n<span class=\"c1\">#5  0x00007ffff62bfb45 in gazebo::physics::World::RunLoop (this=0xbd7950) at /home/jorgehn/gazebo/gazebo/physics/World.cc:481</span>\n<span class=\"c1\">#6  0x00007ffff40745d5 in ?? () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.58.0</span>\n<span class=\"c1\">#7  0x00007ffff65dd6ba in start_thread (arg=0x7fff6e3fa700) at pthread_create.c:333</span>\n<span class=\"c1\">#8  0x00007ffff6be63dd in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span>\n<span class=\"o\">(</span>gdb<span class=\"o\">)</span> whatis iter.second-&gt;on Attempt to take address of value not located in memory.\n</pre></div>\n\n\n<p>I do not know the cause of this null pointer, my suspicion is that I reset the world quite often which causes a race condition to eventually manifest in a null pointer dereference.\nThe reason I suspect this is that in the <code>EventT&lt;T&gt;::Cleanup</code> method of <code>Event.hh</code> there is a mutex. The mutex seems to be designed to protect, <code>connections</code>, but the mutex is not used in any other method. This lead me to believe that the race condition happens when <code>connections</code> is altered during world reset. To test this I put a <code>std::lock_guard</code> in every method in <code>Event.hh</code> and ran my program again. This time the race condition never happened (I ran the program for several hours). To semi verify I removed the <code>std::lock_guard</code> again and the program crashed within 20 minutes of running.</p>\n<p>The mutex in <code>Event.hh</code> is present from Gazebo 7.0.0 (which is the version I first tried) and is still present on master in this repository. However, no other method in <code>EventT&lt;T&gt;</code> uses this mutex.</p>\n<p>Because Gazebo is such a complicated and large software I have not been able to verify that this absolutely solves the problem. I hope someone more knowledgeable about Gazebo can take a look and see if the problem is realistic (could there ever be a race condition with <code>Signal</code>?) and how should the problem be solved (<code>std::lock_guard</code>s all over the place is error prone as demonstrated by this problem if that is indeed the problem).</p>\n<p>The \"fix\" I tested is based on parent <code>28214:a29d8dabed9a gazebo7_7.0.0</code>:</p>\n<div class=\"codehilite language-bashof\"><pre><span></span><span class=\"gh\">diff -r a29d8dabed9a gazebo/common/Event.hh</span>\n<span class=\"gd\">--- a/gazebo/common/Event.hh    Tue Jan 26 01:05:38 2016 +0100</span>\n<span class=\"gi\">+++ b/gazebo/common/Event.hh    Thu Aug 17 10:49:33 2017 +0200</span>\n<span class=\"gu\">@@ -358,6 +358,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -373,6 +374,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -389,6 +391,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -406,6 +409,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -425,6 +429,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -446,6 +451,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -468,6 +474,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -491,6 +498,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections.begin())\n         {\n<span class=\"gu\">@@ -516,6 +524,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -545,6 +554,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -576,6 +586,7 @@</span>\n       {\n         this-&gt;Cleanup();\n\n<span class=\"gi\">+   std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n         this-&gt;myDataPtr-&gt;signaled = true;\n         for (auto iter: this-&gt;myDataPtr-&gt;connections)\n         {\n<span class=\"gu\">@@ -616,6 +627,7 @@</span>\n     template&lt;typename T&gt;\n     ConnectionPtr EventT&lt;T&gt;::Connect(const boost::function&lt;T&gt; &amp;_subscriber)\n     {\n<span class=\"gi\">+      std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n       int index = 0;\n       if (!this-&gt;myDataPtr-&gt;connections.empty())\n       {\n<span class=\"gu\">@@ -645,6 +657,7 @@</span>\n     template&lt;typename T&gt;\n     unsigned int EventT&lt;T&gt;::ConnectionCount() const\n     {\n<span class=\"gi\">+      std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n       return this-&gt;myDataPtr-&gt;connections.size();\n     }\n\n<span class=\"gu\">@@ -653,6 +666,7 @@</span>\n     template&lt;typename T&gt;\n     void EventT&lt;T&gt;::Disconnect(int _id)\n     {\n<span class=\"gi\">+      std::lock_guard&lt;std::mutex&gt; lock(this-&gt;myDataPtr-&gt;mutex);</span>\n       // Find the connection\n       auto const &amp;it = this-&gt;myDataPtr-&gt;connections.find(_id);\n</pre></div>\n\n\n<p>I have not been able to test this on master or with Gazebo8 because of an <a data-is-external-link=\"true\" href=\"https://github.com/ros-simulation/gazebo_ros_pkgs/issues/596\" rel=\"nofollow\">unrelated bug</a> which stops my setup from running.</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": {"name": "7.0", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/242744.json"}}}, "edited_on": null, "created_on": "2017-08-17T09:00:32.052907+00:00", "milestone": null, "updated_on": "2018-04-02T11:20:31.659210+00:00", "type": "issue", "id": 2332}