{"priority": "major", "kind": "bug", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/1855/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/1855.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1855/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/1855/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/1855/gazebo-misuses-collision-collide-bits-as"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/1855/vote"}}, "reporter": {"display_name": "Martin Pecka", "uuid": "{41691c43-4ae0-49ba-ba45-3c36439f5af2}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B41691c43-4ae0-49ba-ba45-3c36439f5af2%7D"}, "html": {"href": "https://bitbucket.org/%7B41691c43-4ae0-49ba-ba45-3c36439f5af2%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/d1ad32a09564f856909994613fdbc37cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMP-1.png"}}, "nickname": "peci1", "type": "user", "account_id": "557058:434ecab2-e510-4ede-8f9a-1c2a5a4032e1"}, "title": "Gazebo misuses collision collide bits as category bits.", "component": {"name": "physics::ODEPhysics", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/122883.json"}}}, "votes": 0, "watches": 5, "content": {"raw": "My feeling is that Gazebo misuses the category bits.\r\n\r\nCompare:\r\n\r\ngazebo/physics/ode/ODEPhysics.cc, Collide() method:\r\n```\r\n#!c++\r\nif ((_collision1->GetSurface()->collideBitmask &_collision2->GetSurface()->collideBitmask) == 0)\r\n    return;\r\n\r\n```\r\n\r\nand\r\n\r\ndeps/opende/src/collision_space_internal.h \r\n\r\n```\r\n#!c++\r\n\r\n// test if the category and collide bitfields match\r\n  if ( ((g1->category_bits & g2->collide_bits) ||\r\n\t(g2->category_bits & g1->collide_bits)) == 0) {\r\n    return;\r\n  }\r\n```\r\n\r\nIt seems that ODEPhysics' Collide() method completely ignores the category bits and incorrectly matches two collide masks against each other. Fortunately, dSpaceCollide() still applies the collision vs. category test, but with the superfluous Collide() constraint, the result is different from what sole ODE would do.\r\n\r\nLet's make a thinking experiment. I have a BOX and a CYLINDER. I want boxes to collide with cylinders, but not other boxes, and vice versa.\r\n\r\nSo I set (reading in binary)\r\n```\r\nBOX:       category 01 collide 10\r\nCYLINDER:  category 10 collide 01\r\n```\r\n\r\nIn pure ODE, the result would be as desired: each object's category is checked aginst the other object's collide mask.\r\nIn Gazebo, the above test is performed, but additionally another `if (10 & 01 == 0) return` is performed, which causes that nothing ever collides.\r\n\r\nPlease, try to tell if I understand all the stuff correctly and haven't done a mistake somewhere in my deliberation. If someone agrees with my ideas, I might try to write a failing test for this.\r\n\r\nAnother problem is that we can't probably fix this without breaking BC (refer e.g. to Issue #1581 and the tutorial linked from there).", "markup": "markdown", "html": "<p>My feeling is that Gazebo misuses the category bits.</p>\n<p>Compare:</p>\n<p>gazebo/physics/ode/ODEPhysics.cc, Collide() method:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">_collision1</span><span class=\"o\">-&gt;</span><span class=\"n\">GetSurface</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">collideBitmask</span> <span class=\"o\">&amp;</span><span class=\"n\">_collision2</span><span class=\"o\">-&gt;</span><span class=\"n\">GetSurface</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">collideBitmask</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n</pre></div>\n\n\n<p>and</p>\n<p>deps/opende/src/collision_space_internal.h </p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"c1\">// test if the category and collide bitfields match</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"p\">((</span><span class=\"n\">g1</span><span class=\"o\">-&gt;</span><span class=\"n\">category_bits</span> <span class=\"o\">&amp;</span> <span class=\"n\">g2</span><span class=\"o\">-&gt;</span><span class=\"n\">collide_bits</span><span class=\"p\">)</span> <span class=\"o\">||</span>\n    <span class=\"p\">(</span><span class=\"n\">g2</span><span class=\"o\">-&gt;</span><span class=\"n\">category_bits</span> <span class=\"o\">&amp;</span> <span class=\"n\">g1</span><span class=\"o\">-&gt;</span><span class=\"n\">collide_bits</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>It seems that ODEPhysics' Collide() method completely ignores the category bits and incorrectly matches two collide masks against each other. Fortunately, dSpaceCollide() still applies the collision vs. category test, but with the superfluous Collide() constraint, the result is different from what sole ODE would do.</p>\n<p>Let's make a thinking experiment. I have a BOX and a CYLINDER. I want boxes to collide with cylinders, but not other boxes, and vice versa.</p>\n<p>So I set (reading in binary)</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">BOX</span><span class=\"o\">:</span>       <span class=\"n\">category</span> <span class=\"mi\">01</span> <span class=\"n\">collide</span> <span class=\"mi\">10</span>\n<span class=\"n\">CYLINDER</span><span class=\"o\">:</span>  <span class=\"n\">category</span> <span class=\"mi\">10</span> <span class=\"n\">collide</span> <span class=\"mi\">01</span>\n</pre></div>\n\n\n<p>In pure ODE, the result would be as desired: each object's category is checked aginst the other object's collide mask.\nIn Gazebo, the above test is performed, but additionally another <code>if (10 &amp; 01 == 0) return</code> is performed, which causes that nothing ever collides.</p>\n<p>Please, try to tell if I understand all the stuff correctly and haven't done a mistake somewhere in my deliberation. If someone agrees with my ideas, I might try to write a failing test for this.</p>\n<p>Another problem is that we can't probably fix this without breaking BC (refer e.g. to Issue <a href=\"#!/osrf/gazebo/issues/1581/add-documentation-and-example-for\" rel=\"nofollow\" title=\"Add documentation and example for SetCategoryBits and SetCollideBits\" class=\"ap-connect-link\">#1581</a> and the tutorial linked from there).</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": {"name": "6.0", "links": {"self": {"href": "data/repositories/osrf/gazebo/versions/170782.json"}}}, "edited_on": null, "created_on": "2016-02-04T17:56:03.476261+00:00", "milestone": null, "updated_on": "2017-03-10T13:24:45.961380+00:00", "type": "issue", "id": 1855}