{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1579/comments/18542729.json"}, "html": {"href": "#!/osrf/gazebo/issues/1579#comment-18542729"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1579.json"}}, "type": "issue", "id": 1579, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Sky consumes significant portion of CPU, even when clouds disable."}, "content": {"raw": "That was my first try, I liked that approach: do not generate the sky until the first message arrives. However, if apply the following patch and run the empty_sky.world, I see no sky in gzclient.\n\n\n```\n#!diff\n\ndiff -r 7c6a01286318 gazebo/rendering/Scene.cc\n--- a/gazebo/rendering/Scene.cc\tFri May 29 13:02:53 2015 -0700\n+++ b/gazebo/rendering/Scene.cc\tTue Jun 02 20:14:48 2015 +0200\n@@ -325,17 +325,6 @@\n   for (uint32_t i = 0; i < this->dataPtr->grids.size(); ++i)\n     this->dataPtr->grids[i]->Init();\n \n-  // Create Sky. This initializes SkyX, and makes it invisible. A Sky\n-  // message must be received (via a scene message or on the ~/sky topic).\n-  try\n-  {\n-    this->SetSky();\n-  }\n-  catch(...)\n-  {\n-    gzerr << \"Failed to create the sky\\n\";\n-  }\n-\n   // Create Fog\n   if (this->dataPtr->sdf->HasElement(\"fog\"))\n   {\n@@ -1475,9 +1467,26 @@\n   // Process the sky message.\n   if (_msg->has_sky())\n   {\n+    // Create Sky. This initializes SkyX, and makes it invisible. A Sky\n+    // message must be received (via a scene message or on the ~/sky topic).\n+    try\n+    {\n+      std::cout << \"Scene::Init()::SetSky()\" << std::endl;\n+      this->SetSky();\n+    }\n+    catch(...)\n+    {\n+      gzerr << \"Failed to create the sky\\n\";\n+    }\n+\n     boost::shared_ptr<msgs::Sky> sm(new msgs::Sky(_msg->sky()));\n     this->OnSkyMsg(sm);\n   }\n+  else\n+  {\n+    this->dataPtr->skyx->remove();\n+    this->dataPtr->skyx = NULL;\n+  }\n \n   if (_msg->has_fog())\n   {\n\n```\nGiving a look into what's is different when moving the `setSky` call out of `Scene::Init`, the only relevant [command executed after the setSky](#!/osrf/gazebo/src/7e3d1fae2c8d7a4a21f8db048430390fb7779e57/gazebo/rendering/Scene.cc?at=default#cl-332) is the message publication of \"scene_info\". I tried to add the same into the previous patch, but it also did not show the sky on gzclient.\n\nIf we go up in the call stack, the call to `Scene::Init` comes from RenderEngine. [After that call there are two relevant comands](#!/osrf/gazebo/src/7e3d1fae2c8d7a4a21f8db048430390fb7779e57/gazebo/rendering/RenderEngine.cc?at=default#cl-201): `this->scenes.push_back(scene);` and `rendering::Events::createScene(_name);` which probably are the ones that do the trick.", "markup": "markdown", "html": "<p>That was my first try, I liked that approach: do not generate the sky until the first message arrives. However, if apply the following patch and run the empty_sky.world, I see no sky in gzclient.</p>\n<div class=\"codehilite language-diff\"><pre><span></span><span class=\"gh\">diff -r 7c6a01286318 gazebo/rendering/Scene.cc</span>\n<span class=\"gd\">--- a/gazebo/rendering/Scene.cc Fri May 29 13:02:53 2015 -0700</span>\n<span class=\"gi\">+++ b/gazebo/rendering/Scene.cc Tue Jun 02 20:14:48 2015 +0200</span>\n<span class=\"gu\">@@ -325,17 +325,6 @@</span>\n   for (uint32_t i = 0; i &lt; this-&gt;dataPtr-&gt;grids.size(); ++i)\n     this-&gt;dataPtr-&gt;grids[i]-&gt;Init();\n\n<span class=\"gd\">-  // Create Sky. This initializes SkyX, and makes it invisible. A Sky</span>\n<span class=\"gd\">-  // message must be received (via a scene message or on the ~/sky topic).</span>\n<span class=\"gd\">-  try</span>\n<span class=\"gd\">-  {</span>\n<span class=\"gd\">-    this-&gt;SetSky();</span>\n<span class=\"gd\">-  }</span>\n<span class=\"gd\">-  catch(...)</span>\n<span class=\"gd\">-  {</span>\n<span class=\"gd\">-    gzerr &lt;&lt; &quot;Failed to create the sky\\n&quot;;</span>\n<span class=\"gd\">-  }</span>\n<span class=\"gd\">-</span>\n   // Create Fog\n   if (this-&gt;dataPtr-&gt;sdf-&gt;HasElement(&quot;fog&quot;))\n   {\n<span class=\"gu\">@@ -1475,9 +1467,26 @@</span>\n   // Process the sky message.\n   if (_msg-&gt;has_sky())\n   {\n<span class=\"gi\">+    // Create Sky. This initializes SkyX, and makes it invisible. A Sky</span>\n<span class=\"gi\">+    // message must be received (via a scene message or on the ~/sky topic).</span>\n<span class=\"gi\">+    try</span>\n<span class=\"gi\">+    {</span>\n<span class=\"gi\">+      std::cout &lt;&lt; &quot;Scene::Init()::SetSky()&quot; &lt;&lt; std::endl;</span>\n<span class=\"gi\">+      this-&gt;SetSky();</span>\n<span class=\"gi\">+    }</span>\n<span class=\"gi\">+    catch(...)</span>\n<span class=\"gi\">+    {</span>\n<span class=\"gi\">+      gzerr &lt;&lt; &quot;Failed to create the sky\\n&quot;;</span>\n<span class=\"gi\">+    }</span>\n<span class=\"gi\">+</span>\n     boost::shared_ptr&lt;msgs::Sky&gt; sm(new msgs::Sky(_msg-&gt;sky()));\n     this-&gt;OnSkyMsg(sm);\n   }\n<span class=\"gi\">+  else</span>\n<span class=\"gi\">+  {</span>\n<span class=\"gi\">+    this-&gt;dataPtr-&gt;skyx-&gt;remove();</span>\n<span class=\"gi\">+    this-&gt;dataPtr-&gt;skyx = NULL;</span>\n<span class=\"gi\">+  }</span>\n\n   if (_msg-&gt;has_fog())\n   {\n</pre></div>\n\n\n<p>Giving a look into what's is different when moving the <code>setSky</code> call out of <code>Scene::Init</code>, the only relevant <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/7e3d1fae2c8d7a4a21f8db048430390fb7779e57/gazebo/rendering/Scene.cc?at=default#cl-332\" rel=\"nofollow\">command executed after the setSky</a> is the message publication of \"scene_info\". I tried to add the same into the previous patch, but it also did not show the sky on gzclient.</p>\n<p>If we go up in the call stack, the call to <code>Scene::Init</code> comes from RenderEngine. <a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/7e3d1fae2c8d7a4a21f8db048430390fb7779e57/gazebo/rendering/RenderEngine.cc?at=default#cl-201\" rel=\"nofollow\">After that call there are two relevant comands</a>: <code>this-&gt;scenes.push_back(scene);</code> and <code>rendering::Events::createScene(_name);</code> which probably are the ones that do the trick.</p>", "type": "rendered"}, "created_on": "2015-06-02T18:38:40.709809+00:00", "user": {"display_name": "Jose Luis Rivero", "uuid": "{d12309b2-f745-42ee-b119-aec4fcdf81fe}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bd12309b2-f745-42ee-b119-aec4fcdf81fe%7D"}, "html": {"href": "https://bitbucket.org/%7Bd12309b2-f745-42ee-b119-aec4fcdf81fe%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/109284c8b83411dbc7492138f6167e9ed=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJR-5.png"}}, "nickname": "Jose Luis Rivero", "type": "user", "account_id": "557058:155a32e2-420c-4d50-98e0-0e722f63f906"}, "updated_on": null, "type": "issue_comment", "id": 18542729}