{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1132/comments/9459138.json"}, "html": {"href": "#!/osrf/gazebo/issues/1132#comment-9459138"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1132.json"}}, "type": "issue", "id": 1132, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Simplify the process of using gazebo as a library even more"}, "content": {"raw": "Thank you for the link. \n\nI think you may have misunderstood my new suggestion.\n\nI agree that it doesn't make sense to handle every possible way to pass command line parameters. Please leave aside the specific parameter type I use for a moment. I think that generally, you want gazebo to be very easy for people to use, and similarly, I think there are other ways to implement setupServer and friends that will help take additional steps towards that goal, because the current argc,argv parameters are a bit opaque and not as easy to use as they could be. \n\nOne possibility is a normal API be created for these functions, where you pass a range of shared libraries to load to one parameter, and additional parameters for whatever other information types. That way there doesn't need to be any assumption that you are parsing command line arguments, because it is an unusual format for general C++ code that is rarely used aside from parsing main(). \n\nThis means implementing in the exact same style normal standard functions or objects are implemented, like anything in `common::*`. Then, if desired, a single overload for the command line arguments version could be implemented to use that API since I expect it would still be necessary.\n\nI haven't looked at all the code so forgive my not being 100% explicit and substituting type2 and type3 for additional parameters aside from shared libraries to load.\n\npossible example:\n\n```\n#!c++\n\n\nSetupServer(std::vector<std::string> pluginsToLoad, type2 arg2, type3 arg3);\n```\n\n\nbetter exmple:\n```\n#!c++\n\n\ntemplate<typename PluginRange>\nSetupServer(PluginRange pluginsToLoad, type2 arg2, type3 arg3);\n```\nthis version could handle pluginsToLoad as `std::vector<string>`, `std::pair<char**,char**>`, `std::list<std::string>`, etc with a single function implementation (i.e. does not require any explicit overloads, aside from the single implicit template overload).\n\nDoes that make sense / explain my thoughts more clearly?\n\nSide notes:\n\n1. with an iterator + template you can cover most command line parameter formats possibilities easily\n2. see boost.range for an explanation of ranges, though not confined to the boost range ", "markup": "markdown", "html": "<p>Thank you for the link. </p>\n<p>I think you may have misunderstood my new suggestion.</p>\n<p>I agree that it doesn't make sense to handle every possible way to pass command line parameters. Please leave aside the specific parameter type I use for a moment. I think that generally, you want gazebo to be very easy for people to use, and similarly, I think there are other ways to implement setupServer and friends that will help take additional steps towards that goal, because the current argc,argv parameters are a bit opaque and not as easy to use as they could be. </p>\n<p>One possibility is a normal API be created for these functions, where you pass a range of shared libraries to load to one parameter, and additional parameters for whatever other information types. That way there doesn't need to be any assumption that you are parsing command line arguments, because it is an unusual format for general C++ code that is rarely used aside from parsing main(). </p>\n<p>This means implementing in the exact same style normal standard functions or objects are implemented, like anything in <code>common::*</code>. Then, if desired, a single overload for the command line arguments version could be implemented to use that API since I expect it would still be necessary.</p>\n<p>I haven't looked at all the code so forgive my not being 100% explicit and substituting type2 and type3 for additional parameters aside from shared libraries to load.</p>\n<p>possible example:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"n\">SetupServer</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&gt;</span> <span class=\"n\">pluginsToLoad</span><span class=\"p\">,</span> <span class=\"n\">type2</span> <span class=\"n\">arg2</span><span class=\"p\">,</span> <span class=\"n\">type3</span> <span class=\"n\">arg3</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>better exmple:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">PluginRange</span><span class=\"o\">&gt;</span>\n<span class=\"n\">SetupServer</span><span class=\"p\">(</span><span class=\"n\">PluginRange</span> <span class=\"n\">pluginsToLoad</span><span class=\"p\">,</span> <span class=\"n\">type2</span> <span class=\"n\">arg2</span><span class=\"p\">,</span> <span class=\"n\">type3</span> <span class=\"n\">arg3</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>this version could handle pluginsToLoad as <code>std::vector&lt;string&gt;</code>, <code>std::pair&lt;char**,char**&gt;</code>, <code>std::list&lt;std::string&gt;</code>, etc with a single function implementation (i.e. does not require any explicit overloads, aside from the single implicit template overload).</p>\n<p>Does that make sense / explain my thoughts more clearly?</p>\n<p>Side notes:</p>\n<ol>\n<li>with an iterator + template you can cover most command line parameter formats possibilities easily</li>\n<li>see boost.range for an explanation of ranges, though not confined to the boost range </li>\n</ol>", "type": "rendered"}, "created_on": "2014-04-03T00:29:40.572348+00:00", "user": {"display_name": "Andrew Hundt", "uuid": "{1e508588-c010-4693-87e5-4923df91390d}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B1e508588-c010-4693-87e5-4923df91390d%7D"}, "html": {"href": "https://bitbucket.org/%7B1e508588-c010-4693-87e5-4923df91390d%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/fb975596131ce08ea7e7472f09b8209dd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsAH-1.png"}}, "nickname": "ahundt", "type": "user", "account_id": "557058:f565cbf4-e097-4b3f-b4db-4889856f7417"}, "updated_on": "2014-04-03T00:37:10.377829+00:00", "type": "issue_comment", "id": 9459138}