{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/2068/comments/31309950.json"}, "html": {"href": "#!/osrf/gazebo/issues/2068#comment-31309950"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/2068.json"}}, "type": "issue", "id": 2068, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Directional friction still broken."}, "content": {"raw": "I did some experiments and I found the origin of this issue. \nThe issue is not related with the variable 'fd2' mentioned in above comment (that is a different issue).\nThe computation is wrong because there's a bug in:\n\n```\n   if (fd != math::Vector3::Zero)\n   {\n     // fdir1 is in body local frame, rotate it into world frame\n    fd = _collision1->GetWorldPose().rot.RotateVector(fd);\n   }\n```\nThe method GetWorldPose() does not return the transformation between the **world** and the **collision reference frame**. It returns the transformation between the **origin of the model** and the **collision reference frame**. So if the robot model is rotated respect to the world frame, fd is wrong. I tested this hypotesis by rotating the robot and observing that GetWorldPose() returns always the same value.\n\n\nI thus fixed the code as follow:\n\n```\n   if (fd != math::Vector3::Zero)\n   {\n     // fdir1 is in body local frame, rotate it into world frame\n    fd = _collision1->GetWorldPose().rot.RotateVector(fd);\n    fd = _collision1->GetModel()->GetWorldPose().rot.RotateVector(fd);\n   }\n```\nThis hack fixes the calculation because the first line computes the transformation between the **origin of the model** and the **collision reference frame** frame while the second one returns the transformation between the **world** and the **origin of the model**.\n\nObviously this is just an hack that fixes the simulation. \n\nThe method _collision1->GetWorldPose() has to be fixed.\n\n\n\n\n\n", "markup": "markdown", "html": "<p>I did some experiments and I found the origin of this issue. \nThe issue is not related with the variable 'fd2' mentioned in above comment (that is a different issue).\nThe computation is wrong because there's a bug in:</p>\n<div class=\"codehilite\"><pre><span></span>   if (fd != math::Vector3::Zero)\n   {\n     // fdir1 is in body local frame, rotate it into world frame\n    fd = _collision1-&gt;GetWorldPose().rot.RotateVector(fd);\n   }\n</pre></div>\n\n\n<p>The method GetWorldPose() does not return the transformation between the <strong>world</strong> and the <strong>collision reference frame</strong>. It returns the transformation between the <strong>origin of the model</strong> and the <strong>collision reference frame</strong>. So if the robot model is rotated respect to the world frame, fd is wrong. I tested this hypotesis by rotating the robot and observing that GetWorldPose() returns always the same value.</p>\n<p>I thus fixed the code as follow:</p>\n<div class=\"codehilite\"><pre><span></span>   if (fd != math::Vector3::Zero)\n   {\n     // fdir1 is in body local frame, rotate it into world frame\n    fd = _collision1-&gt;GetWorldPose().rot.RotateVector(fd);\n    fd = _collision1-&gt;GetModel()-&gt;GetWorldPose().rot.RotateVector(fd);\n   }\n</pre></div>\n\n\n<p>This hack fixes the calculation because the first line computes the transformation between the <strong>origin of the model</strong> and the <strong>collision reference frame</strong> frame while the second one returns the transformation between the <strong>world</strong> and the <strong>origin of the model</strong>.</p>\n<p>Obviously this is just an hack that fixes the simulation. </p>\n<p>The method _collision1-&gt;GetWorldPose() has to be fixed.</p>", "type": "rendered"}, "created_on": "2016-10-12T15:01:29.922716+00:00", "user": {"display_name": "Andrea Ruzzenenti", "uuid": "{e1b5ee2b-de45-4d4a-a5e6-a8ac3fbf68e7}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Be1b5ee2b-de45-4d4a-a5e6-a8ac3fbf68e7%7D"}, "html": {"href": "https://bitbucket.org/%7Be1b5ee2b-de45-4d4a-a5e6-a8ac3fbf68e7%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/23c771650185f3cd68d95b67cb829a12d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsAR-5.png"}}, "nickname": "aerydna", "type": "user", "account_id": "557058:4cda65f8-5ec6-402e-9da4-1c7f61e1a152"}, "updated_on": null, "type": "issue_comment", "id": 31309950}