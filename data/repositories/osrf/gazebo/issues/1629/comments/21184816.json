{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1629/comments/21184816.json"}, "html": {"href": "#!/osrf/gazebo/issues/1629#comment-21184816"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1629.json"}}, "type": "issue", "id": 1629, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Removing model from plugin crashes with null pointer"}, "content": {"raw": "I can confirm the above is indeed the cause of the null pointer with the contact sensor, replacing the contact sensor with one that doesn't try to get its parent at this stage solves the issue. It can simply be worked around by storing the topic name the first time it is calculated and using that to unregister it.\n\nI've also managed to isolate why the segfault occurs, which is a different issue though triggered through a similar mechanism. At the point of the segfault we have at thread 1:\n\n```\nThread 1 (Thread 0x7ffff7f7d880 (LWP 5756)):\n#0  0x00007ffff4da2088 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#1  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#2  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#3  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#4  0x00007ffff4da1e34 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#5  0x00007ffff6303ef6 in gazebo::physics::Base::~Base() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#6  0x00007ffff6340ff9 in gazebo::physics::Link::~Link() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#7  0x00007ffff12eff09 in gazebo::physics::ODELink::~ODELink() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics_ode.so.6\n#8  0x00007ffff5ff71ce in ?? () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#9  0x00007ffff601ae3a in gazebo::sensors::ImuSensor::~ImuSensor() () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#10 0x00007ffff601aed9 in gazebo::sensors::ImuSensor::~ImuSensor() () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#11 0x00007ffff5ff71ce in ?? () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#12 0x00007ffff603915e in gazebo::sensors::SensorManager::SensorContainer::RemoveSensor(std::string const&) () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#13 0x00007ffff6039688 in gazebo::sensors::SensorManager::Update(bool) () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#14 0x00007ffff7bb1037 in gazebo::Server::Run() () from /usr/lib/x86_64-linux-gnu/libgazebo.so.6\n#15 0x0000000000402449 in ?? ()\n#16 0x00007ffff68b7ec5 in __libc_start_main (main=0x402350, argc=2, argv=0x7fffffffd7f8, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffd7e8) at libc-start.c:287\n#17 0x00000000004029b8 in _start ()\n```\n\nMeanwhile at thread 23:\n\n```\nThread 23 (Thread 0x7fff9d1f7700 (LWP 5781)):\n#0  0x00007ffff69150e7 in _int_free (av=0x7fff78000020, p=<optimized out>, have_lock=0) at malloc.c:3987\n#1  0x00007ffff4da00c2 in sdf::Element::~Element() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#2  0x00007ffff4da0349 in sdf::Element::~Element() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#3  0x00007ffff4da1f01 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#4  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#5  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#6  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#7  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#8  0x00007ffff4da1e34 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#9  0x00007ffff4da1e34 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#10 0x00007ffff6303ef6 in gazebo::physics::Base::~Base() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#11 0x00007ffff6354e79 in gazebo::physics::Model::~Model() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#12 0x00007ffff62efe0e in ?? () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#13 0x00007ffff6388386 in gazebo::physics::World::RemoveModel(std::string const&) () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#14 0x00007ffff6388bbc in gazebo::physics::World::ProcessEntityMsgs() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#15 0x00007ffff6391190 in gazebo::physics::World::ProcessMessages() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#16 0x00007ffff6395198 in gazebo::physics::World::Step() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#17 0x00007ffff6395615 in gazebo::physics::World::RunLoop() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#18 0x00007ffff4b6ba4a in ?? () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0\n#19 0x00007ffff5796182 in start_thread (arg=0x7fff9d1f7700) at pthread_create.c:312\n#20 0x00007ffff699047d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111\n```\n\nBoth the main thread and the sensor thread call `Element::Reset()` on the sensor element. This would be fine, if they didn't run consecutively, at some point during both the calls the smart pointers' reference counter of one of these elements goes to zero, and the `Element::~Element()` is called before the call to `Element::Reset()` on the different thread finishes. This call then tries to access the `dataPtr` of the element, which was just deleted by `Element::~Element()`, resulting in the segfault. I'm not sure what the best solution to this problem is, apart from having to make sure that no two threads are resetting the same element consecutively.. Perhaps `Element::Reset()` should be made thread-safe as an issue of `SDFormat`?\n\n@scpeters this issue has become a mess because it's actually separate issues:\n\n1. A bug in the `ContactSensor` as detailed in the previous comment\n2. The segfault from this issue\n3. The original issue with networking, which I haven't reproduced in a while, but might go hand in hand with one of the above\n\nI've little hope anything is going to be solved with the issue in this state. Is it a good idea if I create new bugreports for (1) and (2), leaving this issue for (3) until I have more information about it?", "markup": "markdown", "html": "<p>I can confirm the above is indeed the cause of the null pointer with the contact sensor, replacing the contact sensor with one that doesn't try to get its parent at this stage solves the issue. It can simply be worked around by storing the topic name the first time it is calculated and using that to unregister it.</p>\n<p>I've also managed to isolate why the segfault occurs, which is a different issue though triggered through a similar mechanism. At the point of the segfault we have at thread 1:</p>\n<div class=\"codehilite\"><pre><span></span>Thread 1 (Thread 0x7ffff7f7d880 (LWP 5756)):\n#0  0x00007ffff4da2088 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#1  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#2  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#3  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#4  0x00007ffff4da1e34 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#5  0x00007ffff6303ef6 in gazebo::physics::Base::~Base() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#6  0x00007ffff6340ff9 in gazebo::physics::Link::~Link() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#7  0x00007ffff12eff09 in gazebo::physics::ODELink::~ODELink() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics_ode.so.6\n#8  0x00007ffff5ff71ce in ?? () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#9  0x00007ffff601ae3a in gazebo::sensors::ImuSensor::~ImuSensor() () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#10 0x00007ffff601aed9 in gazebo::sensors::ImuSensor::~ImuSensor() () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#11 0x00007ffff5ff71ce in ?? () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#12 0x00007ffff603915e in gazebo::sensors::SensorManager::SensorContainer::RemoveSensor(std::string const&amp;) () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#13 0x00007ffff6039688 in gazebo::sensors::SensorManager::Update(bool) () from /usr/lib/x86_64-linux-gnu/libgazebo_sensors.so.6\n#14 0x00007ffff7bb1037 in gazebo::Server::Run() () from /usr/lib/x86_64-linux-gnu/libgazebo.so.6\n#15 0x0000000000402449 in ?? ()\n#16 0x00007ffff68b7ec5 in __libc_start_main (main=0x402350, argc=2, argv=0x7fffffffd7f8, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffd7e8) at libc-start.c:287\n#17 0x00000000004029b8 in _start ()\n</pre></div>\n\n\n<p>Meanwhile at thread 23:</p>\n<div class=\"codehilite\"><pre><span></span>Thread 23 (Thread 0x7fff9d1f7700 (LWP 5781)):\n#0  0x00007ffff69150e7 in _int_free (av=0x7fff78000020, p=&lt;optimized out&gt;, have_lock=0) at malloc.c:3987\n#1  0x00007ffff4da00c2 in sdf::Element::~Element() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#2  0x00007ffff4da0349 in sdf::Element::~Element() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#3  0x00007ffff4da1f01 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#4  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#5  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#6  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#7  0x00007ffff4da1ecc in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#8  0x00007ffff4da1e34 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#9  0x00007ffff4da1e34 in sdf::Element::Reset() () from /usr/lib/x86_64-linux-gnu/libsdformat.so.3\n#10 0x00007ffff6303ef6 in gazebo::physics::Base::~Base() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#11 0x00007ffff6354e79 in gazebo::physics::Model::~Model() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#12 0x00007ffff62efe0e in ?? () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#13 0x00007ffff6388386 in gazebo::physics::World::RemoveModel(std::string const&amp;) () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#14 0x00007ffff6388bbc in gazebo::physics::World::ProcessEntityMsgs() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#15 0x00007ffff6391190 in gazebo::physics::World::ProcessMessages() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#16 0x00007ffff6395198 in gazebo::physics::World::Step() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#17 0x00007ffff6395615 in gazebo::physics::World::RunLoop() () from /usr/lib/x86_64-linux-gnu/libgazebo_physics.so.6\n#18 0x00007ffff4b6ba4a in ?? () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0\n#19 0x00007ffff5796182 in start_thread (arg=0x7fff9d1f7700) at pthread_create.c:312\n#20 0x00007ffff699047d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111\n</pre></div>\n\n\n<p>Both the main thread and the sensor thread call <code>Element::Reset()</code> on the sensor element. This would be fine, if they didn't run consecutively, at some point during both the calls the smart pointers' reference counter of one of these elements goes to zero, and the <code>Element::~Element()</code> is called before the call to <code>Element::Reset()</code> on the different thread finishes. This call then tries to access the <code>dataPtr</code> of the element, which was just deleted by <code>Element::~Element()</code>, resulting in the segfault. I'm not sure what the best solution to this problem is, apart from having to make sure that no two threads are resetting the same element consecutively.. Perhaps <code>Element::Reset()</code> should be made thread-safe as an issue of <code>SDFormat</code>?</p>\n<p>@scpeters this issue has become a mess because it's actually separate issues:</p>\n<ol>\n<li>A bug in the <code>ContactSensor</code> as detailed in the previous comment</li>\n<li>The segfault from this issue</li>\n<li>The original issue with networking, which I haven't reproduced in a while, but might go hand in hand with one of the above</li>\n</ol>\n<p>I've little hope anything is going to be solved with the issue in this state. Is it a good idea if I create new bugreports for (1) and (2), leaving this issue for (3) until I have more information about it?</p>", "type": "rendered"}, "created_on": "2015-08-24T08:50:14.479428+00:00", "user": {"display_name": "Elte Hupkes", "uuid": "{f23aa1a9-ae57-493f-8169-fbb59b3eae43}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bf23aa1a9-ae57-493f-8169-fbb59b3eae43%7D"}, "html": {"href": "https://bitbucket.org/%7Bf23aa1a9-ae57-493f-8169-fbb59b3eae43%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/8560ee94d50ba277c411499a45b3d732d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsEH-5.png"}}, "nickname": "ElteHupkes", "type": "user", "account_id": "557058:b758f523-bdaa-4718-964c-03b825bdea8d"}, "updated_on": null, "type": "issue_comment", "id": 21184816}