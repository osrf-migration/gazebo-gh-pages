{"priority": "minor", "kind": "enhancement", "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "links": {"attachments": {"href": "data/repositories/osrf/gazebo/issues/2509/attachments_page=1.json"}, "self": {"href": "data/repositories/osrf/gazebo/issues/2509.json"}, "watch": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/2509/watch"}, "comments": {"href": "data/repositories/osrf/gazebo/issues/2509/comments_page=1.json"}, "html": {"href": "#!/osrf/gazebo/issues/2509/running-physics-world-step-wise"}, "vote": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/issues/2509/vote"}}, "reporter": {"display_name": "Jennifer Buehler", "uuid": "{5949baad-8c43-4d52-9a82-bb8c3511fed8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D"}, "html": {"href": "https://bitbucket.org/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/b28ae0e95eada6ee16f0860c1fa59fdcd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJB-4.png"}}, "nickname": "JenniferBuehler", "type": "user", "account_id": "557058:96bd489a-ec14-4a06-8d31-7bb6d46d1209"}, "title": "Running physics::World step-wise", "component": {"name": "physics", "links": {"self": {"href": "data/repositories/osrf/gazebo/components/122876.json"}}}, "votes": 2, "watches": 3, "content": {"raw": "It would be nice to have a clean way to run the `physics::World` step-wise.  So not starting a thread as it's done by calling `physics::World::Run()`, but instead completely control the loop from outside `World`. \r\n\r\nLet's say we have a `externalLoop()` function in which we would like to update the world\r\n\r\n```cpp\r\nvoid externalLoop(gazebo::physics::WorldPtr &world)\r\n{\r\n  // do initializations\r\n  /* ... */\r\n \r\n  while (/* something */)\r\n  {\r\n       // do one update step for world\r\n      /* ... */\r\n   }\r\n}\r\n```\r\n\r\nThere are currently two options, unless I'm missing some, each of which has drawbacks (discussed below). \r\n\r\n**Option 1**\r\n\r\nCall  `world->RunBlocking(1)` with one iteration (or use `gazebo::runWorld()` which just calls `World::RunBlocking()`). This will cause a call to `World::RunLoop()`.\r\n\r\n```cpp\r\n\r\n  // do initializations\r\n  /* nothing required here */\r\n \r\n  while (/* something */)\r\n  {\r\n       // do one update step for world\r\n     world->RunBlocking(1);\r\n   }\r\n```\r\n\r\nThis comes with the pretty big flaw that because `World::RunLoop` is called repeatedly, the iterations, start time etc. are reset each time. However we would actually just like to ``World::Step()`` in our loop, and not make a whole run with just one iteration.\r\n\r\n** Option 2**\r\n\r\nIn the initialization step, first pause the world and then run it indefinitely (passing 0 as iterations). Inside the loop, then use `World::Step(1)`.    \r\nRunning the world in paused mode will then not update the world (so not calling `World::Update` or increase iterations), it will just keep doing other stuff like publishing world stats. Then, in the loop, we can call `world->Step(1)` which sets `World::stepInc` to the desired iterations, and therefore the `World` thread will actually update the world in its next iteration(s).\r\n\r\n```cpp\r\n  // do initializations\r\n  world->SetPaused(true);\r\n  world->RunLoop(0);\r\n\r\n  while (/* something */)\r\n  {\r\n       // do one update step for world\r\n      world->Step(1);\r\n   }\r\n```\r\nThis achieves the desired behavior, because `World::Step(int)` waits for the `World` thread to actually have done the steps. However technically the world updating is still running from a separate thread. It would be nice to just call `World::Step()` (the version without in parameter) from within our loop.\r\n\r\n\r\n**Improved version?**\r\n\r\nIt would be nice to be able to use an improved version of Option (2), but it would require  modifications to `World`.\r\n\r\nOne option would be to split `World::RunLoop` into three parts: (1) the pre-loop code, and maybe call it `InitExplicitRun()` (2) the loop part, maybe call it `RunWorldSteps` (this can remain private) and (3) the post-loop part, maybe call it `FinishExplicitRun()`.\r\n\r\nSomething like this (have not tested code, just to scetch the idea):\r\n\r\n```cpp\r\n//////////////////////////////////////////////////\r\nvoid World::RunLoop()\r\n{\r\n     InitExplicitRun();\r\n     RunWorldSteps();\r\n     FinishExplicitRun();\r\n}\r\n\r\n//////////////////////////////////////////////////\r\nvoid World::InitExplicitRun()\r\n{\r\n  this->dataPtr->physicsEngine->InitForThread();\r\n\r\n  this->dataPtr->startTime = common::Time::GetWallTime();\r\n\r\n  // This fixes a minor issue when the world is paused before it's started\r\n  if (this->IsPaused())\r\n    this->dataPtr->pauseStartTime = this->dataPtr->startTime;\r\n\r\n  this->dataPtr->prevStepWallTime = common::Time::GetWallTime();\r\n\r\n  // Get the first state\r\n  this->dataPtr->prevStates[0] = WorldState(shared_from_this());\r\n  this->dataPtr->prevStates[1] = WorldState(shared_from_this());\r\n  this->dataPtr->stateToggle = 0;\r\n\r\n  this->dataPtr->logThread =\r\n    new std::thread(std::bind(&World::LogWorker, this));\r\n\r\n  // reset iterations\r\n  this->dataPtr->iterations = 0;\r\n\r\n  // disable physics engine, in case we do not use the internal\r\n  // run thread which calls RunWorldSteps() in which this is done.\r\n  if (util::LogPlay::Instance()->IsOpen())\r\n  {\r\n    this->dataPtr->enablePhysicsEngine = false;\r\n   }\r\n}\r\n\r\n//////////////////////////////////////////////////\r\nvoid World::RunWorldSteps()\r\n{\r\n  if (!util::LogPlay::Instance()->IsOpen())\r\n  {\r\n    for (this->dataPtr->iterations = 0; !this->dataPtr->stop &&\r\n        (!this->dataPtr->stopIterations ||\r\n         (this->dataPtr->iterations < this->dataPtr->stopIterations));)\r\n    {\r\n      this->Step();\r\n    }\r\n  }\r\n  else\r\n  {\r\n    this->dataPtr->enablePhysicsEngine = false;\r\n    for (this->dataPtr->iterations = 0; !this->dataPtr->stop &&\r\n        (!this->dataPtr->stopIterations ||\r\n         (this->dataPtr->iterations < this->dataPtr->stopIterations));)\r\n    {\r\n      this->LogStep();\r\n    }\r\n  }\r\n}\r\n\r\n//////////////////////////////////////////////////\r\nvoid World::FinishExplicitRun()\r\n{\r\n  this->dataPtr->stop = true;\r\n\r\n  if (this->dataPtr->logThread)\r\n  {\r\n    this->dataPtr->logCondition.notify_all();\r\n    {\r\n      std::lock_guard<std::mutex> lock(this->dataPtr->logMutex);\r\n      this->dataPtr->logCondition.notify_all();\r\n    }\r\n    this->dataPtr->logThread->join();\r\n    delete this->dataPtr->logThread;\r\n    this->dataPtr->logThread = nullptr;\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\nIf we had it like that, we could do the following in our loop:\r\n\r\n```cpp\r\nvoid externalLoop(gazebo::physics::WorldPtr &world)\r\n{\r\n  // do initializations\r\n  world->InitExplicitRun();\r\n \r\n  while (/* something */)\r\n  {\r\n       // do one update step for world\r\n      world->Step(1);\r\n   }\r\n  world->FinishExplicitRun();\r\n}\r\n```\r\n\r\nThis would be much cleaner. However it comes with the disadvantage of exposing two new public functions in `World`: `InitExplicitRun()` and `FinishExplicitRun()`.  Also,  minor modifications in `World::Step(int)` would be required to directly call `World::Step()` (without the wait) in case the `World` thread is not running.\r\n\r\nAltogether this could be changes which are acceptable IMO, considering that it would allow better control of the loop from outside... but it does require modifications in `World` which I understand is a big thing.\r\n\r\nAnyway, question: Would you be open to such changes? Or is it better to just use either of the existing options, even if not perfect?\r\n\r\nIf you're open to the changes, I'm happy to post a PR including tests.", "markup": "markdown", "html": "<p>It would be nice to have a clean way to run the <code>physics::World</code> step-wise.  So not starting a thread as it's done by calling <code>physics::World::Run()</code>, but instead completely control the loop from outside <code>World</code>. </p>\n<p>Let's say we have a <code>externalLoop()</code> function in which we would like to update the world</p>\n<div class=\"codehilite language-cpp\"><pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">externalLoop</span><span class=\"p\">(</span><span class=\"n\">gazebo</span><span class=\"o\">::</span><span class=\"n\">physics</span><span class=\"o\">::</span><span class=\"n\">WorldPtr</span> <span class=\"o\">&amp;</span><span class=\"n\">world</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// do initializations</span>\n  <span class=\"cm\">/* ... */</span>\n\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"cm\">/* something */</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n       <span class=\"c1\">// do one update step for world</span>\n      <span class=\"cm\">/* ... */</span>\n   <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>There are currently two options, unless I'm missing some, each of which has drawbacks (discussed below). </p>\n<p><strong>Option 1</strong></p>\n<p>Call  <code>world-&gt;RunBlocking(1)</code> with one iteration (or use <code>gazebo::runWorld()</code> which just calls <code>World::RunBlocking()</code>). This will cause a call to <code>World::RunLoop()</code>.</p>\n<div class=\"codehilite language-cpp\"><pre><span></span>  <span class=\"c1\">// do initializations</span>\n  <span class=\"cm\">/* nothing required here */</span>\n\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"cm\">/* something */</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n       <span class=\"c1\">// do one update step for world</span>\n     <span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">RunBlocking</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n   <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>This comes with the pretty big flaw that because <code>World::RunLoop</code> is called repeatedly, the iterations, start time etc. are reset each time. However we would actually just like to <code>World::Step()</code> in our loop, and not make a whole run with just one iteration.</p>\n<p><strong> Option 2</strong></p>\n<p>In the initialization step, first pause the world and then run it indefinitely (passing 0 as iterations). Inside the loop, then use <code>World::Step(1)</code>.  <br />\nRunning the world in paused mode will then not update the world (so not calling <code>World::Update</code> or increase iterations), it will just keep doing other stuff like publishing world stats. Then, in the loop, we can call <code>world-&gt;Step(1)</code> which sets <code>World::stepInc</code> to the desired iterations, and therefore the <code>World</code> thread will actually update the world in its next iteration(s).</p>\n<div class=\"codehilite language-cpp\"><pre><span></span>  <span class=\"c1\">// do initializations</span>\n  <span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">SetPaused</span><span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">);</span>\n  <span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">RunLoop</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"cm\">/* something */</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n       <span class=\"c1\">// do one update step for world</span>\n      <span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">Step</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n   <span class=\"p\">}</span>\n</pre></div>\n\n\n<p>This achieves the desired behavior, because <code>World::Step(int)</code> waits for the <code>World</code> thread to actually have done the steps. However technically the world updating is still running from a separate thread. It would be nice to just call <code>World::Step()</code> (the version without in parameter) from within our loop.</p>\n<p><strong>Improved version?</strong></p>\n<p>It would be nice to be able to use an improved version of Option (2), but it would require  modifications to <code>World</code>.</p>\n<p>One option would be to split <code>World::RunLoop</code> into three parts: (1) the pre-loop code, and maybe call it <code>InitExplicitRun()</code> (2) the loop part, maybe call it <code>RunWorldSteps</code> (this can remain private) and (3) the post-loop part, maybe call it <code>FinishExplicitRun()</code>.</p>\n<p>Something like this (have not tested code, just to scetch the idea):</p>\n<div class=\"codehilite language-cpp\"><pre><span></span><span class=\"c1\">//////////////////////////////////////////////////</span>\n<span class=\"kt\">void</span> <span class=\"n\">World</span><span class=\"o\">::</span><span class=\"n\">RunLoop</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n     <span class=\"n\">InitExplicitRun</span><span class=\"p\">();</span>\n     <span class=\"n\">RunWorldSteps</span><span class=\"p\">();</span>\n     <span class=\"n\">FinishExplicitRun</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">//////////////////////////////////////////////////</span>\n<span class=\"kt\">void</span> <span class=\"n\">World</span><span class=\"o\">::</span><span class=\"n\">InitExplicitRun</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">physicsEngine</span><span class=\"o\">-&gt;</span><span class=\"n\">InitForThread</span><span class=\"p\">();</span>\n\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span><span class=\"o\">::</span><span class=\"n\">GetWallTime</span><span class=\"p\">();</span>\n\n  <span class=\"c1\">// This fixes a minor issue when the world is paused before it&#39;s started</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">IsPaused</span><span class=\"p\">())</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">pauseStartTime</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">startTime</span><span class=\"p\">;</span>\n\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">prevStepWallTime</span> <span class=\"o\">=</span> <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span><span class=\"o\">::</span><span class=\"n\">GetWallTime</span><span class=\"p\">();</span>\n\n  <span class=\"c1\">// Get the first state</span>\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">prevStates</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">WorldState</span><span class=\"p\">(</span><span class=\"n\">shared_from_this</span><span class=\"p\">());</span>\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">prevStates</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">WorldState</span><span class=\"p\">(</span><span class=\"n\">shared_from_this</span><span class=\"p\">());</span>\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stateToggle</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logThread</span> <span class=\"o\">=</span>\n    <span class=\"k\">new</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">World</span><span class=\"o\">::</span><span class=\"n\">LogWorker</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">));</span>\n\n  <span class=\"c1\">// reset iterations</span>\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">// disable physics engine, in case we do not use the internal</span>\n  <span class=\"c1\">// run thread which calls RunWorldSteps() in which this is done.</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">util</span><span class=\"o\">::</span><span class=\"n\">LogPlay</span><span class=\"o\">::</span><span class=\"n\">Instance</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">IsOpen</span><span class=\"p\">())</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">enablePhysicsEngine</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n   <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">//////////////////////////////////////////////////</span>\n<span class=\"kt\">void</span> <span class=\"n\">World</span><span class=\"o\">::</span><span class=\"n\">RunWorldSteps</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">util</span><span class=\"o\">::</span><span class=\"n\">LogPlay</span><span class=\"o\">::</span><span class=\"n\">Instance</span><span class=\"p\">()</span><span class=\"o\">-&gt;</span><span class=\"n\">IsOpen</span><span class=\"p\">())</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"o\">!</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stop</span> <span class=\"o\">&amp;&amp;</span>\n        <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stopIterations</span> <span class=\"o\">||</span>\n         <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">iterations</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stopIterations</span><span class=\"p\">));)</span>\n    <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">Step</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n  <span class=\"k\">else</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">enablePhysicsEngine</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"o\">!</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stop</span> <span class=\"o\">&amp;&amp;</span>\n        <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stopIterations</span> <span class=\"o\">||</span>\n         <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">iterations</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stopIterations</span><span class=\"p\">));)</span>\n    <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">LogStep</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">//////////////////////////////////////////////////</span>\n<span class=\"kt\">void</span> <span class=\"n\">World</span><span class=\"o\">::</span><span class=\"n\">FinishExplicitRun</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">stop</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logThread</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logCondition</span><span class=\"p\">.</span><span class=\"n\">notify_all</span><span class=\"p\">();</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logMutex</span><span class=\"p\">);</span>\n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logCondition</span><span class=\"p\">.</span><span class=\"n\">notify_all</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logThread</span><span class=\"o\">-&gt;</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"k\">delete</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logThread</span><span class=\"p\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">dataPtr</span><span class=\"o\">-&gt;</span><span class=\"n\">logThread</span> <span class=\"o\">=</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>If we had it like that, we could do the following in our loop:</p>\n<div class=\"codehilite language-cpp\"><pre><span></span><span class=\"kt\">void</span> <span class=\"nf\">externalLoop</span><span class=\"p\">(</span><span class=\"n\">gazebo</span><span class=\"o\">::</span><span class=\"n\">physics</span><span class=\"o\">::</span><span class=\"n\">WorldPtr</span> <span class=\"o\">&amp;</span><span class=\"n\">world</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"c1\">// do initializations</span>\n  <span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">InitExplicitRun</span><span class=\"p\">();</span>\n\n  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"cm\">/* something */</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n       <span class=\"c1\">// do one update step for world</span>\n      <span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">Step</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n   <span class=\"p\">}</span>\n  <span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">FinishExplicitRun</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>This would be much cleaner. However it comes with the disadvantage of exposing two new public functions in <code>World</code>: <code>InitExplicitRun()</code> and <code>FinishExplicitRun()</code>.  Also,  minor modifications in <code>World::Step(int)</code> would be required to directly call <code>World::Step()</code> (without the wait) in case the <code>World</code> thread is not running.</p>\n<p>Altogether this could be changes which are acceptable IMO, considering that it would allow better control of the loop from outside... but it does require modifications in <code>World</code> which I understand is a big thing.</p>\n<p>Anyway, question: Would you be open to such changes? Or is it better to just use either of the existing options, even if not perfect?</p>\n<p>If you're open to the changes, I'm happy to post a PR including tests.</p>", "type": "rendered"}, "assignee": null, "state": "new", "version": null, "edited_on": null, "created_on": "2018-08-09T08:29:36.871620+00:00", "milestone": null, "updated_on": "2018-09-28T09:12:58.999269+00:00", "type": "issue", "id": 2509}