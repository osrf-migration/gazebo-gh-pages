{"pagelen": 100, "values": [{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1095/comments/9052844.json"}, "html": {"href": "#!/osrf/gazebo/issues/1095#comment-9052844"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1095.json"}}, "type": "issue", "id": 1095, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Add api to freeze joint at current configuration"}, "content": {"raw": "There are two possible ways to lock a joint in generalized coordinate based physics engines:\n(a) Adding upper/lower joint limit constraints (as you described above)\n(b) Changing the joint actuation type from dynamic to kinematic\n\nIn (a), to make the joint to stay at the configuration, the constraint solver should compute appropriate constraint forces for every simulation steps. Since the constraint is not hard constraint, it may cause constraint errors or jittering.\n\nWhereas in (b), the joint can be treated as kinematic joint, which means the dynamics engine does not compute forward dynamics for the joint but compute inverse dynamics. Inverse dynamics calculates joint torque given joint state and acceleration. This method does not lead any constraint error and does not need to compute constraint force. Gerneralized coordinate based physics engines (like `DART` or `Simbody`) can implement this functionality by hybrid (forward + inverse) dynamics algorithm. \n\nI think (b) would be efficient and accurate way to implement joint lock for generalized coordinate based physics engines unless the user want to add control input to the kinematic joint. It would be nice to create the joint lock function as virtual function so that the each physic engine can override it.", "markup": "markdown", "html": "<p>There are two possible ways to lock a joint in generalized coordinate based physics engines:\n(a) Adding upper/lower joint limit constraints (as you described above)\n(b) Changing the joint actuation type from dynamic to kinematic</p>\n<p>In (a), to make the joint to stay at the configuration, the constraint solver should compute appropriate constraint forces for every simulation steps. Since the constraint is not hard constraint, it may cause constraint errors or jittering.</p>\n<p>Whereas in (b), the joint can be treated as kinematic joint, which means the dynamics engine does not compute forward dynamics for the joint but compute inverse dynamics. Inverse dynamics calculates joint torque given joint state and acceleration. This method does not lead any constraint error and does not need to compute constraint force. Gerneralized coordinate based physics engines (like <code>DART</code> or <code>Simbody</code>) can implement this functionality by hybrid (forward + inverse) dynamics algorithm. </p>\n<p>I think (b) would be efficient and accurate way to implement joint lock for generalized coordinate based physics engines unless the user want to add control input to the kinematic joint. It would be nice to create the joint lock function as virtual function so that the each physic engine can override it.</p>", "type": "rendered"}, "created_on": "2014-03-10T20:17:50.026113+00:00", "user": {"display_name": "Jeongseok Lee", "uuid": "{3907b560-aed7-43bd-bfa9-fd9873322291}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B3907b560-aed7-43bd-bfa9-fd9873322291%7D"}, "html": {"href": "https://bitbucket.org/%7B3907b560-aed7-43bd-bfa9-fd9873322291%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/242819b368397b2b4cddf273b2ba9bf8d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJL-0.png"}}, "nickname": "jlee02", "type": "user", "account_id": "557058:e3fbdece-a1d8-4fb6-a9f1-236ecb09bd9d"}, "updated_on": "2014-03-10T20:18:17.455149+00:00", "type": "issue_comment", "id": 9052844}, {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1095/comments/30610587.json"}, "html": {"href": "#!/osrf/gazebo/issues/1095#comment-30610587"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1095.json"}}, "type": "issue", "id": 1095, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Add api to freeze joint at current configuration"}, "content": {"raw": null, "markup": "markdown", "html": "", "type": "rendered"}, "created_on": "2016-09-14T19:22:58.535904+00:00", "user": {"display_name": "Nate Koenig", "uuid": "{c862cdd9-fcc8-4419-9fc7-e20db14b8fcb}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D"}, "html": {"href": "https://bitbucket.org/%7Bc862cdd9-fcc8-4419-9fc7-e20db14b8fcb%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:095b1e12-74ed-4e20-b44f-2f0745b616e0/ca24bb11-4787-4b14-a20d-d91835e9bde2/128"}}, "nickname": "Nathan Koenig", "type": "user", "account_id": "557058:095b1e12-74ed-4e20-b44f-2f0745b616e0"}, "updated_on": null, "type": "issue_comment", "id": 30610587}], "page": 1, "size": 2}