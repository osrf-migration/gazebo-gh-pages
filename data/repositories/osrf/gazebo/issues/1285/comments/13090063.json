{"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1285/comments/13090063.json"}, "html": {"href": "#!/osrf/gazebo/issues/1285#comment-13090063"}}, "issue": {"links": {"self": {"href": "data/repositories/osrf/gazebo/issues/1285.json"}}, "type": "issue", "id": 1285, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "title": "Improve sensor noise modeling"}, "content": {"raw": "@scpeters, I've coded up Wiener and Ornstein-Uhlenbeck noise models along the same lines as the Gaussian noise model already in Gazebo. However, since these are stochastic noise processes, I needed to modify the ```Noise::Apply``` and ```Noise:ApplyImpl``` prototype functions to accept a time epoch for the noise perturbation:\n\n```c++\n    /// \\class Noise Noise.hh\n    /// \\brief Noise models for sensor output signals.\n    class GAZEBO_VISIBLE Noise\n    {\n\n      ...\n\n      /// \\brief Apply noise to input data value.\n      /// \\param[in] _in Input data value.\n      /// \\param[t] _t Elapsed simulation time\n      /// \\return Data with noise applied.\n      public: double Apply(double _in, const common::Time &_t = common::Time::Zero);\n\n      /// \\brief Apply noise to input data value. This gets overriden by\n      /// derived classes, and called by Apply.\n      /// \\param[in] _in Input data value.\n      /// \\param[t] _t Elapsed simulation time\n      /// \\return Data with noise applied.\n      public: virtual double ApplyImpl(double _in, const common::Time &_t);\n\n      ...\n\n};\n\n```\n\nI'm not yet ready to do a pull request, but you can see my work in progress here:\n\n* [Gazebo changes](https://bitbucket.org/asymingt/gazebo/branch/time_correlated_noise)\n\n* [SDFormat changes](https://bitbucket.org/asymingt/sdformat/branch/time_correlated_noise) \n\n\nMy intention is to also write unit tests for both models, but I seem to be getting stuck every time at this point (for both Wiener and Ornstein)\n\n```c++\n  // Make sure that we have a valid noise model\n  sensors::OrnsteinNoiseModelPtr noiseModel =\n      boost::dynamic_pointer_cast<sensors::OrnsteinNoiseModel>(_noise);\n  ASSERT_TRUE(noiseModel);\n```\n\nFor some reason ```noiseModel``` is always evaluated as false. \n\nFinally, we need to think whether or not it makes sense to include the epoch inside the noise callback for custom types. I didn't change this, because I imagine that there already exist many SensorPlugins which use the current callback that takes only the current sensor value ```_in```. Including a second epoch argument ```_t``` would likely break compatibility, which is a bad thing...", "markup": "markdown", "html": "<p>@scpeters, I've coded up Wiener and Ornstein-Uhlenbeck noise models along the same lines as the Gaussian noise model already in Gazebo. However, since these are stochastic noise processes, I needed to modify the <code>Noise::Apply</code> and <code>Noise:ApplyImpl</code> prototype functions to accept a time epoch for the noise perturbation:</p>\n<div class=\"codehilite language-c++\"><pre><span></span>    <span class=\"c1\">/// \\class Noise Noise.hh</span>\n    <span class=\"c1\">/// \\brief Noise models for sensor output signals.</span>\n    <span class=\"k\">class</span> <span class=\"nc\">GAZEBO_VISIBLE</span> <span class=\"n\">Noise</span>\n    <span class=\"p\">{</span>\n\n      <span class=\"p\">...</span>\n\n      <span class=\"c1\">/// \\brief Apply noise to input data value.</span>\n      <span class=\"c1\">/// \\param[in] _in Input data value.</span>\n      <span class=\"c1\">/// \\param[t] _t Elapsed simulation time</span>\n      <span class=\"c1\">/// \\return Data with noise applied.</span>\n      <span class=\"k\">public</span><span class=\"o\">:</span> <span class=\"kt\">double</span> <span class=\"n\">Apply</span><span class=\"p\">(</span><span class=\"kt\">double</span> <span class=\"n\">_in</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span> <span class=\"o\">&amp;</span><span class=\"n\">_t</span> <span class=\"o\">=</span> <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span><span class=\"o\">::</span><span class=\"n\">Zero</span><span class=\"p\">);</span>\n\n      <span class=\"c1\">/// \\brief Apply noise to input data value. This gets overriden by</span>\n      <span class=\"c1\">/// derived classes, and called by Apply.</span>\n      <span class=\"c1\">/// \\param[in] _in Input data value.</span>\n      <span class=\"c1\">/// \\param[t] _t Elapsed simulation time</span>\n      <span class=\"c1\">/// \\return Data with noise applied.</span>\n      <span class=\"k\">public</span><span class=\"o\">:</span> <span class=\"k\">virtual</span> <span class=\"kt\">double</span> <span class=\"n\">ApplyImpl</span><span class=\"p\">(</span><span class=\"kt\">double</span> <span class=\"n\">_in</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span> <span class=\"o\">&amp;</span><span class=\"n\">_t</span><span class=\"p\">);</span>\n\n      <span class=\"p\">...</span>\n\n<span class=\"p\">};</span>\n</pre></div>\n\n\n<p>I'm not yet ready to do a pull request, but you can see my work in progress here:</p>\n<ul>\n<li>\n<p><a data-is-external-link=\"true\" href=\"https://bitbucket.org/asymingt/gazebo/branch/time_correlated_noise\" rel=\"nofollow\">Gazebo changes</a></p>\n</li>\n<li>\n<p><a data-is-external-link=\"true\" href=\"https://bitbucket.org/asymingt/sdformat/branch/time_correlated_noise\" rel=\"nofollow\">SDFormat changes</a> </p>\n</li>\n</ul>\n<p>My intention is to also write unit tests for both models, but I seem to be getting stuck every time at this point (for both Wiener and Ornstein)</p>\n<div class=\"codehilite language-c++\"><pre><span></span>  <span class=\"c1\">// Make sure that we have a valid noise model</span>\n  <span class=\"n\">sensors</span><span class=\"o\">::</span><span class=\"n\">OrnsteinNoiseModelPtr</span> <span class=\"n\">noiseModel</span> <span class=\"o\">=</span>\n      <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">dynamic_pointer_cast</span><span class=\"o\">&lt;</span><span class=\"n\">sensors</span><span class=\"o\">::</span><span class=\"n\">OrnsteinNoiseModel</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_noise</span><span class=\"p\">);</span>\n  <span class=\"n\">ASSERT_TRUE</span><span class=\"p\">(</span><span class=\"n\">noiseModel</span><span class=\"p\">);</span>\n</pre></div>\n\n\n<p>For some reason <code>noiseModel</code> is always evaluated as false. </p>\n<p>Finally, we need to think whether or not it makes sense to include the epoch inside the noise callback for custom types. I didn't change this, because I imagine that there already exist many SensorPlugins which use the current callback that takes only the current sensor value <code>_in</code>. Including a second epoch argument <code>_t</code> would likely break compatibility, which is a bad thing...</p>", "type": "rendered"}, "created_on": "2014-10-20T11:43:04.869062+00:00", "user": {"display_name": "Andrew Symington", "uuid": "{db1311fc-02e6-442e-84a1-4bb85dfee5ba}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bdb1311fc-02e6-442e-84a1-4bb85dfee5ba%7D"}, "html": {"href": "https://bitbucket.org/%7Bdb1311fc-02e6-442e-84a1-4bb85dfee5ba%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:cab3b56e-7c24-487c-b07f-05e0600adf54/8a009f21-29b8-4d43-98ed-2677428e17ff/128"}}, "nickname": "asymingt", "type": "user", "account_id": "557058:cab3b56e-7c24-487c-b07f-05e0600adf54"}, "updated_on": "2014-10-20T11:58:31.698174+00:00", "type": "issue_comment", "id": 13090063}