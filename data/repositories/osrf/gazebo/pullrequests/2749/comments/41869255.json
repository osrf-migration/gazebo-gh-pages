{"links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2749/comments/41869255.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/diff/mxgrey/gazebo:36d8a20dceb8..a2e24ead6b45?path=gazebo%2Fphysics%2Fdart%2FDARTPhysicsPrivate.hh"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2749/_/diff#comment-41869255"}}, "parent": {"id": 41867224, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2749/comments/41867224.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2749/_/diff#comment-41867224"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 2749, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2749.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2749"}}, "title": "Fix Issue #1477 and #1090"}, "content": {"raw": "I'm a pretty firm believer in using initializer lists rather than in-class initialization. Granted, a big part of that is because historically I've had member variables visible from headers, but that's something we avoid in the Gazebo codebases by using PIMPL, so that argument isn't super relevant here. I still favor initialization lists, because it forces you to see the order in which members are getting initialized right at the locations in the code where they are being initialized, which can be important for catching subtle bugs.\n\nI can certainly see the appeal of initializing inside the class definition, because it allows you to \"set and forget\", but I think a \"set and forget\" mentality carries a lot of risks with it. Of course leaving it unset and then accidentally forgetting to ever set it is even riskier, so I don't think there's any clear winner here. So my personal preference is to exercise strict self-discipline by never relying on \"set and forget\" and always obsessively writing an initialization in every constructor overload immediately after I've introduced a new member variable to a class definition (assuming it's a variable which does not have a sane default initialization). But again, I don't think there's a clear winner.\n\nEdit: Also, you can't always count on it to be possible to perform an in-class initialization (depending on how the member variable defines its constructor and assignment operator), whereas you can always count on the initialization list. So strictly using initialization lists guarantees that all your initializations are happening consistently in one place (or rather, one category of places: the constructor definitions).", "markup": "markdown", "html": "<p>I'm a pretty firm believer in using initializer lists rather than in-class initialization. Granted, a big part of that is because historically I've had member variables visible from headers, but that's something we avoid in the Gazebo codebases by using PIMPL, so that argument isn't super relevant here. I still favor initialization lists, because it forces you to see the order in which members are getting initialized right at the locations in the code where they are being initialized, which can be important for catching subtle bugs.</p>\n<p>I can certainly see the appeal of initializing inside the class definition, because it allows you to \"set and forget\", but I think a \"set and forget\" mentality carries a lot of risks with it. Of course leaving it unset and then accidentally forgetting to ever set it is even riskier, so I don't think there's any clear winner here. So my personal preference is to exercise strict self-discipline by never relying on \"set and forget\" and always obsessively writing an initialization in every constructor overload immediately after I've introduced a new member variable to a class definition (assuming it's a variable which does not have a sane default initialization). But again, I don't think there's a clear winner.</p>\n<p>Edit: Also, you can't always count on it to be possible to perform an in-class initialization (depending on how the member variable defines its constructor and assignment operator), whereas you can always count on the initialization list. So strictly using initialization lists guarantees that all your initializations are happening consistently in one place (or rather, one category of places: the constructor definitions).</p>", "type": "rendered"}, "created_on": "2017-08-01T02:30:39.951259+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "inline": {"to": null, "from": null, "outdated": true, "path": "gazebo/physics/dart/DARTPhysicsPrivate.hh"}, "updated_on": "2017-08-01T02:34:46.810406+00:00", "type": "pullrequest_comment", "id": 41869255}