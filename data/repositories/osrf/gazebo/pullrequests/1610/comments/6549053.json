{"links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/1610/comments/6549053.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/1610/_/diff#comment-6549053"}}, "parent": {"id": 6548840, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/1610/comments/6548840.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/1610/_/diff#comment-6548840"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 1610, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/1610.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/1610"}}, "title": "simbody contact manager integration for issue #865"}, "content": {"raw": "Hi, Steve. If by \"move an object\" you mean do something that is initiated from another thread (like user input to the GUI), then I think there might be a lock call missing. Updates from another thread should only be done in between steps, never while a step is in progress. There is already a suitable lock because John has run into this several times before.\n\nIt might not be the lock. The contact visualization connection is new code that John just got working on Friday and I could see it in the stack trace you sent. When it gets called it expects the State to be relatively up to date (\"realized\" through Velocity stage) which is always the case after a step. But an outside interrupt that makes a state change (like moving something) invalidates the cached computations in the state and needs to be realized again afterwards.So even if it were locked properly it might invalidate the state. If that's what is happening then either the interrupting thread should be sure to call realize again, or there should be a realize(state, Stage::Velocity) prior to calling the new contact reporting code. My preference would be to have the interrupting thread fix the state so that realize() doesn't have to be called every time, but it doesn't matter much since it is very cheap if the state is already up to date.", "markup": "markdown", "html": "<p>Hi, Steve. If by \"move an object\" you mean do something that is initiated from another thread (like user input to the GUI), then I think there might be a lock call missing. Updates from another thread should only be done in between steps, never while a step is in progress. There is already a suitable lock because John has run into this several times before.</p>\n<p>It might not be the lock. The contact visualization connection is new code that John just got working on Friday and I could see it in the stack trace you sent. When it gets called it expects the State to be relatively up to date (\"realized\" through Velocity stage) which is always the case after a step. But an outside interrupt that makes a state change (like moving something) invalidates the cached computations in the state and needs to be realized again afterwards.So even if it were locked properly it might invalidate the state. If that's what is happening then either the interrupting thread should be sure to call realize again, or there should be a realize(state, Stage::Velocity) prior to calling the new contact reporting code. My preference would be to have the interrupting thread fix the state so that realize() doesn't have to be called every time, but it doesn't matter much since it is very cheap if the state is already up to date.</p>", "type": "rendered"}, "created_on": "2015-04-28T23:43:48.803429+00:00", "user": {"display_name": "Michael Sherman", "uuid": "{997c6f1e-e2a3-4f0e-8fa4-fed745840d50}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B997c6f1e-e2a3-4f0e-8fa4-fed745840d50%7D"}, "html": {"href": "https://bitbucket.org/%7B997c6f1e-e2a3-4f0e-8fa4-fed745840d50%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/355dea43ed612b7be3c9361df2d52213d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsMS-2.png"}}, "nickname": "sherm1", "type": "user", "account_id": "557058:4590c319-b75f-4187-93d4-6cec61da74f7"}, "updated_on": "2015-04-28T23:43:48.810347+00:00", "type": "pullrequest_comment", "id": 6549053}