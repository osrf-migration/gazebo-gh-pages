{"links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2840/comments/52847672.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2840/_/diff#comment-52847672"}}, "parent": {"id": 52846961, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2840/comments/52846961.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2840/_/diff#comment-52846961"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 2840, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2840.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2840"}}, "title": "Move BUILD_TYPE_* macros to test_config.h (#2343)"}, "content": {"raw": "I don't see how a downstream user could be doing anything safely with these macros.\n\nEach time you install a different build type of Gazebo, these macros will get changed in your `include` directory. The user would have to ensure that they only have one build type installed at a time, or else these macros may be incorrect (e.g. they might link to a debug build of the library, but if the last build that they installed was a release version, then the headers will incorrectly indicate that they are linking to a release build).\n\nIf anything, the user should use their own build script to indicate to their project what build type they're using. Or, if we want to be really nice, we could use\n\n`target_compile_definitions(gazebo PUBLIC GAZEBO_BUILD_TYPE_$<CONFIG>=1)`\n\nIf we add that to our gazebo cmake script and export the gazebo targets, then as long as the user finds and links to gazebo using an imported target in cmake, their library or application will receive the compile definition, without needing to include any header.\n\nIt's also worth noting that our current scheme does not work for multi-configuration generators like Visual Studio. Users will be left with the macros for whatever build type was chosen at configuration time, and the macro will not be corrected if they ever switch build types from within Visual Studio. The `target_compile_definitions(~)` proposal would work for multi-configuration generators (as long as we use the `$<CONFIG>` generator expression).", "markup": "markdown", "html": "<p>I don't see how a downstream user could be doing anything safely with these macros.</p>\n<p>Each time you install a different build type of Gazebo, these macros will get changed in your <code>include</code> directory. The user would have to ensure that they only have one build type installed at a time, or else these macros may be incorrect (e.g. they might link to a debug build of the library, but if the last build that they installed was a release version, then the headers will incorrectly indicate that they are linking to a release build).</p>\n<p>If anything, the user should use their own build script to indicate to their project what build type they're using. Or, if we want to be really nice, we could use</p>\n<p><code>target_compile_definitions(gazebo PUBLIC GAZEBO_BUILD_TYPE_$&lt;CONFIG&gt;=1)</code></p>\n<p>If we add that to our gazebo cmake script and export the gazebo targets, then as long as the user finds and links to gazebo using an imported target in cmake, their library or application will receive the compile definition, without needing to include any header.</p>\n<p>It's also worth noting that our current scheme does not work for multi-configuration generators like Visual Studio. Users will be left with the macros for whatever build type was chosen at configuration time, and the macro will not be corrected if they ever switch build types from within Visual Studio. The <code>target_compile_definitions(~)</code> proposal would work for multi-configuration generators (as long as we use the <code>$&lt;CONFIG&gt;</code> generator expression).</p>", "type": "rendered"}, "created_on": "2018-01-02T21:58:50.050685+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-01-02T21:58:50.052811+00:00", "type": "pullrequest_comment", "id": 52847672}