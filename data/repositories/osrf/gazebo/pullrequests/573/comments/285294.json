{"links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/573/comments/285294.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/573/_/diff#comment-285294"}}, "parent": {"id": 285237, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/573/comments/285237.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/573/_/diff#comment-285237"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 573, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/573.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/573"}}, "title": "Fix for log segfault"}, "content": {"raw": "I have seen the SensorManager_TEST.InitRemove segfault several times on my machine in the same way. In the backtraces, the seg-fault occurs in the sensor update thread making physics calls, like ODEMultiRayShape::UpdateCallback and dSpaceCollide2, while another thread is calling the sensor destructor.\n\nGlancing at SensorManager,\n\n[SensorContainer::RemoveSensor](#!/osrf/gazebo/src/eacff658f3ec5e89577ad00a10dfc03b75b2f87b/gazebo/sensors/SensorManager.cc?at=default#cl-578) locks SensorContainer::mutex before erasing sensors\n\n[SensorContainer::RemoveSensors](#!/osrf/gazebo/src/eacff658f3ec5e89577ad00a10dfc03b75b2f87b/gazebo/sensors/SensorManager.cc?at=default#cl-619) does not lock anything before erasing sensors\n\n[SensorContainer::RunLoop](#!/osrf/gazebo/src/eacff658f3ec5e89577ad00a10dfc03b75b2f87b/gazebo/sensors/SensorManager.cc?at=default#cl-439) uses a variety of mutexes, but it does not lock SensorContainer::mutex during updates.\n\nMy guess is that we need a mutex lock to prevent sensor deletion during an update.\n\nI created issue #715 for this.", "markup": "markdown", "html": "<p>I have seen the SensorManager_TEST.InitRemove segfault several times on my machine in the same way. In the backtraces, the seg-fault occurs in the sensor update thread making physics calls, like ODEMultiRayShape::UpdateCallback and dSpaceCollide2, while another thread is calling the sensor destructor.</p>\n<p>Glancing at SensorManager,</p>\n<p><a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/eacff658f3ec5e89577ad00a10dfc03b75b2f87b/gazebo/sensors/SensorManager.cc?at=default#cl-578\" rel=\"nofollow\">SensorContainer::RemoveSensor</a> locks SensorContainer::mutex before erasing sensors</p>\n<p><a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/eacff658f3ec5e89577ad00a10dfc03b75b2f87b/gazebo/sensors/SensorManager.cc?at=default#cl-619\" rel=\"nofollow\">SensorContainer::RemoveSensors</a> does not lock anything before erasing sensors</p>\n<p><a data-is-external-link=\"true\" href=\"#!/osrf/gazebo/src/eacff658f3ec5e89577ad00a10dfc03b75b2f87b/gazebo/sensors/SensorManager.cc?at=default#cl-439\" rel=\"nofollow\">SensorContainer::RunLoop</a> uses a variety of mutexes, but it does not lock SensorContainer::mutex during updates.</p>\n<p>My guess is that we need a mutex lock to prevent sensor deletion during an update.</p>\n<p>I created issue <a href=\"#!/osrf/gazebo/issues/715/sensormanager_testinitremove-seg-fault\" rel=\"nofollow\" title=\"SensorManager_TEST.InitRemove seg-fault\" class=\"ap-connect-link\"><s>#715</s></a> for this.</p>", "type": "rendered"}, "created_on": "2013-06-02T08:44:08.109400+00:00", "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}, "updated_on": "2013-06-02T08:48:43.880104+00:00", "type": "pullrequest_comment", "id": 285294}