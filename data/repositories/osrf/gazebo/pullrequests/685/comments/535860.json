{"links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/685/comments/535860.json"}, "code": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/diff/osrf/gazebo:None..None?path=gazebo%2Fsensors%2FSensor.cc"}, "html": {"href": "#!/osrf/gazebo/pull-requests/685/_/diff#comment-535860"}}, "parent": {"id": 526213, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/685/comments/526213.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/685/_/diff#comment-526213"}}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 685, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/685.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/685"}}, "title": "Fix regression of #236, also contact_sensor test #796"}, "content": {"raw": "If we prefer to wrap the lock we could invert the condition that surrounds the unlock() and write a return statement. Something like this:\n\n\n```\n#!c++\n\n//////////////////////////////////////////////////\nvoid Sensor::Update(bool _force)\n{\n  if (this->IsActive() || _force)\n  {\n    {\n      boost::mutex::scoped_lock lock(this->mutexLastUpdateTime);\n      common::Time simTime;\n      if (this->category == IMAGE && this->scene)\n        simTime = this->scene->GetSimTime();\n      else\n        simTime = this->world->GetSimTime();\n\n      if (simTime == this->lastUpdateTime && !_force)\n        return;\n\n      // Adjust time-to-update period to compensate for delays caused by another\n      // sensor's update in the same thread.\n      common::Time adjustedElapsed = simTime - this->lastUpdateTime +\n          this->updateDelay;\n\n      if (adjustedElapsed < this->updatePeriod && !_force)\n        return;\n\n      this->updateDelay = std::max(common::Time::Zero,\n          adjustedElapsed - this->updatePeriod);\n\n      // if delay is more than a full update period, then give up trying\n      // to catch up. This happens normally when the sensor just changed from\n      // an inactive to an active state, or the sensor just cannot hit its\n      // target update rate (worst case).\n      if (this->updateDelay >= this->updatePeriod)\n        this->updateDelay = common::Time::Zero;\n\n      this->lastUpdateTime = simTime;\n    }\n    this->UpdateImpl(_force);\n    this->updated();\n  }\n}\n```", "markup": "markdown", "html": "<p>If we prefer to wrap the lock we could invert the condition that surrounds the unlock() and write a return statement. Something like this:</p>\n<div class=\"codehilite language-c++\"><pre><span></span><span class=\"c1\">//////////////////////////////////////////////////</span>\n<span class=\"kt\">void</span> <span class=\"n\">Sensor</span><span class=\"o\">::</span><span class=\"n\">Update</span><span class=\"p\">(</span><span class=\"kt\">bool</span> <span class=\"n\">_force</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">IsActive</span><span class=\"p\">()</span> <span class=\"o\">||</span> <span class=\"n\">_force</span><span class=\"p\">)</span>\n  <span class=\"p\">{</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">mutexLastUpdateTime</span><span class=\"p\">);</span>\n      <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span> <span class=\"n\">simTime</span><span class=\"p\">;</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">category</span> <span class=\"o\">==</span> <span class=\"n\">IMAGE</span> <span class=\"o\">&amp;&amp;</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">scene</span><span class=\"p\">)</span>\n        <span class=\"n\">simTime</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">scene</span><span class=\"o\">-&gt;</span><span class=\"n\">GetSimTime</span><span class=\"p\">();</span>\n      <span class=\"k\">else</span>\n        <span class=\"n\">simTime</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">world</span><span class=\"o\">-&gt;</span><span class=\"n\">GetSimTime</span><span class=\"p\">();</span>\n\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">simTime</span> <span class=\"o\">==</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">lastUpdateTime</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">_force</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n\n      <span class=\"c1\">// Adjust time-to-update period to compensate for delays caused by another</span>\n      <span class=\"c1\">// sensor&#39;s update in the same thread.</span>\n      <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span> <span class=\"n\">adjustedElapsed</span> <span class=\"o\">=</span> <span class=\"n\">simTime</span> <span class=\"o\">-</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">lastUpdateTime</span> <span class=\"o\">+</span>\n          <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updateDelay</span><span class=\"p\">;</span>\n\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">adjustedElapsed</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updatePeriod</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">_force</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n\n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updateDelay</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span><span class=\"o\">::</span><span class=\"n\">Zero</span><span class=\"p\">,</span>\n          <span class=\"n\">adjustedElapsed</span> <span class=\"o\">-</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updatePeriod</span><span class=\"p\">);</span>\n\n      <span class=\"c1\">// if delay is more than a full update period, then give up trying</span>\n      <span class=\"c1\">// to catch up. This happens normally when the sensor just changed from</span>\n      <span class=\"c1\">// an inactive to an active state, or the sensor just cannot hit its</span>\n      <span class=\"c1\">// target update rate (worst case).</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updateDelay</span> <span class=\"o\">&gt;=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updatePeriod</span><span class=\"p\">)</span>\n        <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updateDelay</span> <span class=\"o\">=</span> <span class=\"n\">common</span><span class=\"o\">::</span><span class=\"n\">Time</span><span class=\"o\">::</span><span class=\"n\">Zero</span><span class=\"p\">;</span>\n\n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">lastUpdateTime</span> <span class=\"o\">=</span> <span class=\"n\">simTime</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">UpdateImpl</span><span class=\"p\">(</span><span class=\"n\">_force</span><span class=\"p\">);</span>\n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">updated</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre></div>", "type": "rendered"}, "created_on": "2013-09-05T18:54:43.756258+00:00", "user": {"display_name": "Carlos Ag\u00fcero", "uuid": "{da8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D"}, "html": {"href": "https://bitbucket.org/%7Bda8a8e89-4bb0-421b-bd0e-dbbed3d4ed6a%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/692bf15758111acaddae4da15a47f9e5d=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsCA-0.png"}}, "nickname": "caguero", "type": "user", "account_id": "557058:4ded1ddf-947e-4154-bbd1-3dba24f1bdbd"}, "inline": {"to": null, "from": null, "outdated": false, "path": "gazebo/sensors/Sensor.cc"}, "updated_on": "2013-09-05T18:54:43.766430+00:00", "type": "pullrequest_comment", "id": 535860}