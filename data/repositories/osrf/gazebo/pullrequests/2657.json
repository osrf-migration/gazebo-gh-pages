{"rendered": {"description": {"raw": "I believe I stumbled over a bug in the transport system which sometimes stalls the message publishing of a `transport::Publisher`. This can be triggered when using `Publisher::Publish()` in blocking mode (parameter \\_block=true).\r\n\r\nThis is a multi-threading related issue which I think should be fixed in any case (also for non-blocking mode).\r\n\r\nIt's probably easiest to explain the issue on code snippets of the existing code.\r\n\r\nFor easy reference: `OnPublishComplete` is the function which should be called at the time just after a message has just been sent (which can happen from another thread). It decreases a counter for this message ID, and deletes the entry from the buffer if the counter reaches zero. This basically helps to keep track on the number of times this function was called for each message.   \r\nNote that the `this->pubIds` map is protected by `this->mutex`.\r\n\r\n```C++\r\nvoid Publisher::OnPublishComplete(uint32_t _id) \r\n{ \r\n boost::mutex::scoped_lock lock(this->mutex); \r\n \r\n std::map<uint32_t, int>::iterator iter = this->pubIds.find(_id); \r\n if (iter != this->pubIds.end() && (--iter->second) <= 0) \r\n this->pubIds.erase(iter); \r\n} \r\n```\r\n\r\nThen there is the function `SendMessage()` which is called from `Publisher::Publish()` when in blocking mode. The blocking is supposed to wait until the message is \"written out\" (*minor side issue:* this is a phrasing in the comments that could maybe be changed, because the actual \"writing out\" still happens asynchronously from `Publication`, so a call of `Publisher::Publish(..block=true)` will not actually guarantee the message has been written out!).\r\n\r\n```C++\r\nvoid Publisher::SendMessage()                                                   \r\n{                                                                               \r\n  std::list<MessagePtr> localBuffer;                                            \r\n  std::list<uint32_t> localIds;                                                 \r\n                                                                                \r\n  {                                                                             \r\n    boost::mutex::scoped_lock lock(this->mutex);                                \r\n    if (!this->pubIds.empty() || this->messages.empty())                        \r\n      return;                                                                   \r\n                                                                                \r\n    for (unsigned int i = 0; i < this->messages.size(); ++i)                    \r\n    {                                                                           \r\n      this->pubId = (this->pubId + 1) % 10000;                                  \r\n      this->pubIds[this->pubId] = 0;                                            \r\n      localIds.push_back(this->pubId);                                          \r\n    }                                                                           \r\n                                                                                \r\n    std::copy(this->messages.begin(), this->messages.end(),                     \r\n        std::back_inserter(localBuffer));                                       \r\n    this->messages.clear();                                                     \r\n  }\r\n  ...\r\n```\r\n\r\nThis first part basically has copied everything into local buffers (presumably to avoid blocking the mutex too long and to avoid deadlocks). This is all trivial, except one crucial thing to note here: If there are any message ID's still hanging around in `this->pubID`, this function won't do anything more - no \"writing out\" happens. This can be interpreted as *\"if there are any messages which have not finished publishing yet, don't proceed, and instead keep them in the `this->messages `buffer until the next time SendMessage() is called\"*. I guess this was done in order to ensure that messages are sent out in the right order (?).\r\n\r\nNext, the copies of `messages` and `pubIDs` are used to actually publish the messages using `transport::Publication::Publish()`, which will trigger a call to `OnPublishComplete()` **once for each subscriber callback** of `Publication`. A subscriber callback however is used for **remote subscribers** only (started in a separate terminal). It's probably possible to add subscriber callbacks in different ways too. But here it's only important that if we have local subscribers (as in all the gtests as far as I can see), we won't have a subscriber callback.   \r\n*Bottom line:* `Publication::Publish()` basically returns the number of times the `OnPublishComplete()` callback has been triggered per remote subscriber (Note that with remote subscribers, the actual calling of OnPublishComplete() happens asynchronously: the subscriber callback `SubscriptionTransport::HandleData()` only enqueues the message).\r\n\r\n```C++\r\n  ...\r\n  // Only send messages if there is something to send                           \r\n  if (!localBuffer.empty())                                                     \r\n  {                                                                             \r\n    std::list<uint32_t>::iterator pubIter = localIds.begin();                   \r\n                                                                                \r\n    // Send all the current messages                                            \r\n    for (std::list<MessagePtr>::iterator iter = localBuffer.begin();            \r\n        iter != localBuffer.end(); ++iter, ++pubIter)                           \r\n    {                                                                           \r\n      // Send the latest message.                                               \r\n      int result = this->publication->Publish(*iter,                            \r\n          boost::bind(&Publisher::OnPublishComplete, this, _1), *pubIter);\r\n      ...\r\n```\r\n\r\nSo I believe the intention is to expect a certain amount of calls to `OnPublishComplete()`. To achieve this, the `this->pubIds` is set with the message ID as key, and as a value the expected number of calls:\r\n\r\n```C++\r\n      ...\r\n      if (result > 0)                                                           \r\n        this->pubIds[*pubIter] = result;                                        \r\n      else                                                                      \r\n        this->pubIds.erase(*pubIter);                                           \r\n    }\r\n    ...\r\n```\r\n\r\nPlease correct me if I have misunderstood this intention.\r\n\r\nThere is a few issues with the above bit of code:\r\n\r\n*  `pubIds` is not mutex protected as it should be.\r\n* If we have only local subscribers, the counter should still be set to 1, because `OnPublishComplete` will still be called once.\r\n* It is possible (randomly due to threads) that by the time `this->pubIds` is set to the value of `result`, `OnPublishComplete()` has already been called, and the entry in `pubIds` has already been erased. This has happened to me, which brought me onto this issue in the first place. In this case, if we have remote subscribers, we will just re-add it here, and **it will never be removed again**! Which will in turn cause all future calls to `SendMessage()` to not do anything, as per condition `!this->pubIds.empty()` in the beginning of the function. So we have a \"publishing dead-end\".\r\n\r\nThe tricky bit is that this only happens when using remote subscribers, which may be a reason why it has gone unnoticed in the automated tests so far? Because if there are only local subscribers, `result` is 0, and the buffer will just always be cleared (it will not really be used actually). So the issue won't arise at all.\r\n\r\nThis PR proposes a way to fix this up, though it's not ready to be merged as there could be better (but more intrusive) solutions to this. I've put it up for discussion. I added some more comments to the code to explain what's going on. \r\n\r\nI've also added a test file which still requires to start a remote publisher manually (by `gz topic -e <topic>`), which is something that should be simulated instead.  \r\nYou can trigger the failure case by commenting `TEMP_NEW_APPROACH_TEST` in Publisher.cc, which will then use the old code. You may have to try a few times because of the randomness, sometimes it can still succeed with the old code.\r\n\r\nOne last thing: It would be important to let the user know that if they are only using \"blocking\" calls to `Publisher::Publish()`, it is *not* guaranteed that the message has actually already been sent. It may still sit in the queue, and it may actually be necessary to call `Publisher::SendMessage()` again to make sure the queue has been emptied. See also comments in the code.", "markup": "markdown", "html": "<p>I believe I stumbled over a bug in the transport system which sometimes stalls the message publishing of a <code>transport::Publisher</code>. This can be triggered when using <code>Publisher::Publish()</code> in blocking mode (parameter _block=true).</p>\n<p>This is a multi-threading related issue which I think should be fixed in any case (also for non-blocking mode).</p>\n<p>It's probably easiest to explain the issue on code snippets of the existing code.</p>\n<p>For easy reference: <code>OnPublishComplete</code> is the function which should be called at the time just after a message has just been sent (which can happen from another thread). It decreases a counter for this message ID, and deletes the entry from the buffer if the counter reaches zero. This basically helps to keep track on the number of times this function was called for each message. <br />\nNote that the <code>this-&gt;pubIds</code> map is protected by <code>this-&gt;mutex</code>.</p>\n<div class=\"codehilite language-C++\"><pre><span></span><span class=\"kt\">void</span> <span class=\"n\">Publisher</span><span class=\"o\">::</span><span class=\"n\">OnPublishComplete</span><span class=\"p\">(</span><span class=\"kt\">uint32_t</span> <span class=\"n\">_id</span><span class=\"p\">)</span> \n<span class=\"p\">{</span> \n <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex</span><span class=\"p\">);</span> \n\n <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">map</span><span class=\"o\">&lt;</span><span class=\"kt\">uint32_t</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;::</span><span class=\"n\">iterator</span> <span class=\"n\">iter</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">_id</span><span class=\"p\">);</span> \n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">iter</span> <span class=\"o\">!=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"o\">--</span><span class=\"n\">iter</span><span class=\"o\">-&gt;</span><span class=\"n\">second</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> \n <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">erase</span><span class=\"p\">(</span><span class=\"n\">iter</span><span class=\"p\">);</span> \n<span class=\"p\">}</span> \n</pre></div>\n\n\n<p>Then there is the function <code>SendMessage()</code> which is called from <code>Publisher::Publish()</code> when in blocking mode. The blocking is supposed to wait until the message is \"written out\" (<em>minor side issue:</em> this is a phrasing in the comments that could maybe be changed, because the actual \"writing out\" still happens asynchronously from <code>Publication</code>, so a call of <code>Publisher::Publish(..block=true)</code> will not actually guarantee the message has been written out!).</p>\n<div class=\"codehilite language-C++\"><pre><span></span><span class=\"kt\">void</span> <span class=\"n\">Publisher</span><span class=\"o\">::</span><span class=\"n\">SendMessage</span><span class=\"p\">()</span>                                                   \n<span class=\"p\">{</span>                                                                               \n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"n\">MessagePtr</span><span class=\"o\">&gt;</span> <span class=\"n\">localBuffer</span><span class=\"p\">;</span>                                            \n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">uint32_t</span><span class=\"o\">&gt;</span> <span class=\"n\">localIds</span><span class=\"p\">;</span>                                                 \n\n  <span class=\"p\">{</span>                                                                             \n    <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex</span><span class=\"p\">);</span>                                \n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">()</span> <span class=\"o\">||</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span>                        \n      <span class=\"k\">return</span><span class=\"p\">;</span>                                                                   \n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>                    \n    <span class=\"p\">{</span>                                                                           \n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">10000</span><span class=\"p\">;</span>                                  \n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">[</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>                                            \n      <span class=\"n\">localIds</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span><span class=\"p\">);</span>                                          \n    <span class=\"p\">}</span>                                                                           \n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">(),</span>                     \n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">back_inserter</span><span class=\"p\">(</span><span class=\"n\">localBuffer</span><span class=\"p\">));</span>                                       \n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">();</span>                                                     \n  <span class=\"p\">}</span>\n  <span class=\"p\">...</span>\n</pre></div>\n\n\n<p>This first part basically has copied everything into local buffers (presumably to avoid blocking the mutex too long and to avoid deadlocks). This is all trivial, except one crucial thing to note here: If there are any message ID's still hanging around in <code>this-&gt;pubID</code>, this function won't do anything more - no \"writing out\" happens. This can be interpreted as <em>\"if there are any messages which have not finished publishing yet, don't proceed, and instead keep them in the <code>this-&gt;messages</code>buffer until the next time SendMessage() is called\"</em>. I guess this was done in order to ensure that messages are sent out in the right order (?).</p>\n<p>Next, the copies of <code>messages</code> and <code>pubIDs</code> are used to actually publish the messages using <code>transport::Publication::Publish()</code>, which will trigger a call to <code>OnPublishComplete()</code> <strong>once for each subscriber callback</strong> of <code>Publication</code>. A subscriber callback however is used for <strong>remote subscribers</strong> only (started in a separate terminal). It's probably possible to add subscriber callbacks in different ways too. But here it's only important that if we have local subscribers (as in all the gtests as far as I can see), we won't have a subscriber callback. <br />\n<em>Bottom line:</em> <code>Publication::Publish()</code> basically returns the number of times the <code>OnPublishComplete()</code> callback has been triggered per remote subscriber (Note that with remote subscribers, the actual calling of OnPublishComplete() happens asynchronously: the subscriber callback <code>SubscriptionTransport::HandleData()</code> only enqueues the message).</p>\n<div class=\"codehilite language-C++\"><pre><span></span>  <span class=\"p\">...</span>\n  <span class=\"c1\">// Only send messages if there is something to send                           </span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">localBuffer</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span>                                                     \n  <span class=\"p\">{</span>                                                                             \n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">uint32_t</span><span class=\"o\">&gt;::</span><span class=\"n\">iterator</span> <span class=\"n\">pubIter</span> <span class=\"o\">=</span> <span class=\"n\">localIds</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>                   \n\n    <span class=\"c1\">// Send all the current messages                                            </span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"n\">MessagePtr</span><span class=\"o\">&gt;::</span><span class=\"n\">iterator</span> <span class=\"n\">iter</span> <span class=\"o\">=</span> <span class=\"n\">localBuffer</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>            \n        <span class=\"n\">iter</span> <span class=\"o\">!=</span> <span class=\"n\">localBuffer</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">iter</span><span class=\"p\">,</span> <span class=\"o\">++</span><span class=\"n\">pubIter</span><span class=\"p\">)</span>                           \n    <span class=\"p\">{</span>                                                                           \n      <span class=\"c1\">// Send the latest message.                                               </span>\n      <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">publication</span><span class=\"o\">-&gt;</span><span class=\"n\">Publish</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">iter</span><span class=\"p\">,</span>                            \n          <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Publisher</span><span class=\"o\">::</span><span class=\"n\">OnPublishComplete</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">_1</span><span class=\"p\">),</span> <span class=\"o\">*</span><span class=\"n\">pubIter</span><span class=\"p\">);</span>\n      <span class=\"p\">...</span>\n</pre></div>\n\n\n<p>So I believe the intention is to expect a certain amount of calls to <code>OnPublishComplete()</code>. To achieve this, the <code>this-&gt;pubIds</code> is set with the message ID as key, and as a value the expected number of calls:</p>\n<div class=\"codehilite language-C++\"><pre><span></span>      <span class=\"p\">...</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">result</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>                                                           \n        <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"n\">pubIter</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">;</span>                                        \n      <span class=\"k\">else</span>                                                                      \n        <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">erase</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">pubIter</span><span class=\"p\">);</span>                                           \n    <span class=\"p\">}</span>\n    <span class=\"p\">...</span>\n</pre></div>\n\n\n<p>Please correct me if I have misunderstood this intention.</p>\n<p>There is a few issues with the above bit of code:</p>\n<ul>\n<li><code>pubIds</code> is not mutex protected as it should be.</li>\n<li>If we have only local subscribers, the counter should still be set to 1, because <code>OnPublishComplete</code> will still be called once.</li>\n<li>It is possible (randomly due to threads) that by the time <code>this-&gt;pubIds</code> is set to the value of <code>result</code>, <code>OnPublishComplete()</code> has already been called, and the entry in <code>pubIds</code> has already been erased. This has happened to me, which brought me onto this issue in the first place. In this case, if we have remote subscribers, we will just re-add it here, and <strong>it will never be removed again</strong>! Which will in turn cause all future calls to <code>SendMessage()</code> to not do anything, as per condition <code>!this-&gt;pubIds.empty()</code> in the beginning of the function. So we have a \"publishing dead-end\".</li>\n</ul>\n<p>The tricky bit is that this only happens when using remote subscribers, which may be a reason why it has gone unnoticed in the automated tests so far? Because if there are only local subscribers, <code>result</code> is 0, and the buffer will just always be cleared (it will not really be used actually). So the issue won't arise at all.</p>\n<p>This PR proposes a way to fix this up, though it's not ready to be merged as there could be better (but more intrusive) solutions to this. I've put it up for discussion. I added some more comments to the code to explain what's going on. </p>\n<p>I've also added a test file which still requires to start a remote publisher manually (by <code>gz topic -e &lt;topic&gt;</code>), which is something that should be simulated instead.<br />\nYou can trigger the failure case by commenting <code>TEMP_NEW_APPROACH_TEST</code> in Publisher.cc, which will then use the old code. You may have to try a few times because of the randomness, sometimes it can still succeed with the old code.</p>\n<p>One last thing: It would be important to let the user know that if they are only using \"blocking\" calls to <code>Publisher::Publish()</code>, it is <em>not</em> guaranteed that the message has actually already been sent. It may still sit in the queue, and it may actually be necessary to call <code>Publisher::SendMessage()</code> again to make sure the queue has been emptied. See also comments in the code.</p>", "type": "rendered"}, "title": {"raw": "Fixing issue in which publishing of messages gets stuck.", "markup": "markdown", "html": "<p>Fixing issue in which publishing of messages gets stuck.</p>", "type": "rendered"}}, "type": "pullrequest", "description": "I believe I stumbled over a bug in the transport system which sometimes stalls the message publishing of a `transport::Publisher`. This can be triggered when using `Publisher::Publish()` in blocking mode (parameter \\_block=true).\r\n\r\nThis is a multi-threading related issue which I think should be fixed in any case (also for non-blocking mode).\r\n\r\nIt's probably easiest to explain the issue on code snippets of the existing code.\r\n\r\nFor easy reference: `OnPublishComplete` is the function which should be called at the time just after a message has just been sent (which can happen from another thread). It decreases a counter for this message ID, and deletes the entry from the buffer if the counter reaches zero. This basically helps to keep track on the number of times this function was called for each message.   \r\nNote that the `this->pubIds` map is protected by `this->mutex`.\r\n\r\n```C++\r\nvoid Publisher::OnPublishComplete(uint32_t _id) \r\n{ \r\n boost::mutex::scoped_lock lock(this->mutex); \r\n \r\n std::map<uint32_t, int>::iterator iter = this->pubIds.find(_id); \r\n if (iter != this->pubIds.end() && (--iter->second) <= 0) \r\n this->pubIds.erase(iter); \r\n} \r\n```\r\n\r\nThen there is the function `SendMessage()` which is called from `Publisher::Publish()` when in blocking mode. The blocking is supposed to wait until the message is \"written out\" (*minor side issue:* this is a phrasing in the comments that could maybe be changed, because the actual \"writing out\" still happens asynchronously from `Publication`, so a call of `Publisher::Publish(..block=true)` will not actually guarantee the message has been written out!).\r\n\r\n```C++\r\nvoid Publisher::SendMessage()                                                   \r\n{                                                                               \r\n  std::list<MessagePtr> localBuffer;                                            \r\n  std::list<uint32_t> localIds;                                                 \r\n                                                                                \r\n  {                                                                             \r\n    boost::mutex::scoped_lock lock(this->mutex);                                \r\n    if (!this->pubIds.empty() || this->messages.empty())                        \r\n      return;                                                                   \r\n                                                                                \r\n    for (unsigned int i = 0; i < this->messages.size(); ++i)                    \r\n    {                                                                           \r\n      this->pubId = (this->pubId + 1) % 10000;                                  \r\n      this->pubIds[this->pubId] = 0;                                            \r\n      localIds.push_back(this->pubId);                                          \r\n    }                                                                           \r\n                                                                                \r\n    std::copy(this->messages.begin(), this->messages.end(),                     \r\n        std::back_inserter(localBuffer));                                       \r\n    this->messages.clear();                                                     \r\n  }\r\n  ...\r\n```\r\n\r\nThis first part basically has copied everything into local buffers (presumably to avoid blocking the mutex too long and to avoid deadlocks). This is all trivial, except one crucial thing to note here: If there are any message ID's still hanging around in `this->pubID`, this function won't do anything more - no \"writing out\" happens. This can be interpreted as *\"if there are any messages which have not finished publishing yet, don't proceed, and instead keep them in the `this->messages `buffer until the next time SendMessage() is called\"*. I guess this was done in order to ensure that messages are sent out in the right order (?).\r\n\r\nNext, the copies of `messages` and `pubIDs` are used to actually publish the messages using `transport::Publication::Publish()`, which will trigger a call to `OnPublishComplete()` **once for each subscriber callback** of `Publication`. A subscriber callback however is used for **remote subscribers** only (started in a separate terminal). It's probably possible to add subscriber callbacks in different ways too. But here it's only important that if we have local subscribers (as in all the gtests as far as I can see), we won't have a subscriber callback.   \r\n*Bottom line:* `Publication::Publish()` basically returns the number of times the `OnPublishComplete()` callback has been triggered per remote subscriber (Note that with remote subscribers, the actual calling of OnPublishComplete() happens asynchronously: the subscriber callback `SubscriptionTransport::HandleData()` only enqueues the message).\r\n\r\n```C++\r\n  ...\r\n  // Only send messages if there is something to send                           \r\n  if (!localBuffer.empty())                                                     \r\n  {                                                                             \r\n    std::list<uint32_t>::iterator pubIter = localIds.begin();                   \r\n                                                                                \r\n    // Send all the current messages                                            \r\n    for (std::list<MessagePtr>::iterator iter = localBuffer.begin();            \r\n        iter != localBuffer.end(); ++iter, ++pubIter)                           \r\n    {                                                                           \r\n      // Send the latest message.                                               \r\n      int result = this->publication->Publish(*iter,                            \r\n          boost::bind(&Publisher::OnPublishComplete, this, _1), *pubIter);\r\n      ...\r\n```\r\n\r\nSo I believe the intention is to expect a certain amount of calls to `OnPublishComplete()`. To achieve this, the `this->pubIds` is set with the message ID as key, and as a value the expected number of calls:\r\n\r\n```C++\r\n      ...\r\n      if (result > 0)                                                           \r\n        this->pubIds[*pubIter] = result;                                        \r\n      else                                                                      \r\n        this->pubIds.erase(*pubIter);                                           \r\n    }\r\n    ...\r\n```\r\n\r\nPlease correct me if I have misunderstood this intention.\r\n\r\nThere is a few issues with the above bit of code:\r\n\r\n*  `pubIds` is not mutex protected as it should be.\r\n* If we have only local subscribers, the counter should still be set to 1, because `OnPublishComplete` will still be called once.\r\n* It is possible (randomly due to threads) that by the time `this->pubIds` is set to the value of `result`, `OnPublishComplete()` has already been called, and the entry in `pubIds` has already been erased. This has happened to me, which brought me onto this issue in the first place. In this case, if we have remote subscribers, we will just re-add it here, and **it will never be removed again**! Which will in turn cause all future calls to `SendMessage()` to not do anything, as per condition `!this->pubIds.empty()` in the beginning of the function. So we have a \"publishing dead-end\".\r\n\r\nThe tricky bit is that this only happens when using remote subscribers, which may be a reason why it has gone unnoticed in the automated tests so far? Because if there are only local subscribers, `result` is 0, and the buffer will just always be cleared (it will not really be used actually). So the issue won't arise at all.\r\n\r\nThis PR proposes a way to fix this up, though it's not ready to be merged as there could be better (but more intrusive) solutions to this. I've put it up for discussion. I added some more comments to the code to explain what's going on. \r\n\r\nI've also added a test file which still requires to start a remote publisher manually (by `gz topic -e <topic>`), which is something that should be simulated instead.  \r\nYou can trigger the failure case by commenting `TEMP_NEW_APPROACH_TEST` in Publisher.cc, which will then use the old code. You may have to try a few times because of the randomness, sometimes it can still succeed with the old code.\r\n\r\nOne last thing: It would be important to let the user know that if they are only using \"blocking\" calls to `Publisher::Publish()`, it is *not* guaranteed that the message has actually already been sent. It may still sit in the queue, and it may actually be necessary to call `Publisher::SendMessage()` again to make sure the queue has been emptied. See also comments in the code.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/pullrequests/2657/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/diffstat/osrf/gazebo:562cf6ef3995%0Dde4206af18d7?from_pullrequest_id=2657"}, "commits": {"href": "data/repositories/osrf/gazebo/pullrequests/2657/commits.json"}, "self": {"href": "data/repositories/osrf/gazebo/pullrequests/2657.json"}, "comments": {"href": "data/repositories/osrf/gazebo/pullrequests/2657/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/pullrequests/2657/merge"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2657"}, "activity": {"href": "data/repositories/osrf/gazebo/pullrequests/2657/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/diff/osrf/gazebo:562cf6ef3995%0Dde4206af18d7?from_pullrequest_id=2657"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/pullrequests/2657/approve"}, "statuses": {"href": "data/repositories/osrf/gazebo/pullrequests/2657/statuses_page=1.json"}}, "title": "Fixing issue in which publishing of messages gets stuck.", "close_source_branch": false, "reviewers": [], "id": 2657, "destination": {"commit": {"hash": "de4206af18d7", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo/commit/de4206af18d7.json"}, "html": {"href": "#!/osrf/gazebo/commits/de4206af18d7"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "branch": {"name": "default"}}, "created_on": "2017-03-15T07:56:23.597604+00:00", "summary": {"raw": "I believe I stumbled over a bug in the transport system which sometimes stalls the message publishing of a `transport::Publisher`. This can be triggered when using `Publisher::Publish()` in blocking mode (parameter \\_block=true).\r\n\r\nThis is a multi-threading related issue which I think should be fixed in any case (also for non-blocking mode).\r\n\r\nIt's probably easiest to explain the issue on code snippets of the existing code.\r\n\r\nFor easy reference: `OnPublishComplete` is the function which should be called at the time just after a message has just been sent (which can happen from another thread). It decreases a counter for this message ID, and deletes the entry from the buffer if the counter reaches zero. This basically helps to keep track on the number of times this function was called for each message.   \r\nNote that the `this->pubIds` map is protected by `this->mutex`.\r\n\r\n```C++\r\nvoid Publisher::OnPublishComplete(uint32_t _id) \r\n{ \r\n boost::mutex::scoped_lock lock(this->mutex); \r\n \r\n std::map<uint32_t, int>::iterator iter = this->pubIds.find(_id); \r\n if (iter != this->pubIds.end() && (--iter->second) <= 0) \r\n this->pubIds.erase(iter); \r\n} \r\n```\r\n\r\nThen there is the function `SendMessage()` which is called from `Publisher::Publish()` when in blocking mode. The blocking is supposed to wait until the message is \"written out\" (*minor side issue:* this is a phrasing in the comments that could maybe be changed, because the actual \"writing out\" still happens asynchronously from `Publication`, so a call of `Publisher::Publish(..block=true)` will not actually guarantee the message has been written out!).\r\n\r\n```C++\r\nvoid Publisher::SendMessage()                                                   \r\n{                                                                               \r\n  std::list<MessagePtr> localBuffer;                                            \r\n  std::list<uint32_t> localIds;                                                 \r\n                                                                                \r\n  {                                                                             \r\n    boost::mutex::scoped_lock lock(this->mutex);                                \r\n    if (!this->pubIds.empty() || this->messages.empty())                        \r\n      return;                                                                   \r\n                                                                                \r\n    for (unsigned int i = 0; i < this->messages.size(); ++i)                    \r\n    {                                                                           \r\n      this->pubId = (this->pubId + 1) % 10000;                                  \r\n      this->pubIds[this->pubId] = 0;                                            \r\n      localIds.push_back(this->pubId);                                          \r\n    }                                                                           \r\n                                                                                \r\n    std::copy(this->messages.begin(), this->messages.end(),                     \r\n        std::back_inserter(localBuffer));                                       \r\n    this->messages.clear();                                                     \r\n  }\r\n  ...\r\n```\r\n\r\nThis first part basically has copied everything into local buffers (presumably to avoid blocking the mutex too long and to avoid deadlocks). This is all trivial, except one crucial thing to note here: If there are any message ID's still hanging around in `this->pubID`, this function won't do anything more - no \"writing out\" happens. This can be interpreted as *\"if there are any messages which have not finished publishing yet, don't proceed, and instead keep them in the `this->messages `buffer until the next time SendMessage() is called\"*. I guess this was done in order to ensure that messages are sent out in the right order (?).\r\n\r\nNext, the copies of `messages` and `pubIDs` are used to actually publish the messages using `transport::Publication::Publish()`, which will trigger a call to `OnPublishComplete()` **once for each subscriber callback** of `Publication`. A subscriber callback however is used for **remote subscribers** only (started in a separate terminal). It's probably possible to add subscriber callbacks in different ways too. But here it's only important that if we have local subscribers (as in all the gtests as far as I can see), we won't have a subscriber callback.   \r\n*Bottom line:* `Publication::Publish()` basically returns the number of times the `OnPublishComplete()` callback has been triggered per remote subscriber (Note that with remote subscribers, the actual calling of OnPublishComplete() happens asynchronously: the subscriber callback `SubscriptionTransport::HandleData()` only enqueues the message).\r\n\r\n```C++\r\n  ...\r\n  // Only send messages if there is something to send                           \r\n  if (!localBuffer.empty())                                                     \r\n  {                                                                             \r\n    std::list<uint32_t>::iterator pubIter = localIds.begin();                   \r\n                                                                                \r\n    // Send all the current messages                                            \r\n    for (std::list<MessagePtr>::iterator iter = localBuffer.begin();            \r\n        iter != localBuffer.end(); ++iter, ++pubIter)                           \r\n    {                                                                           \r\n      // Send the latest message.                                               \r\n      int result = this->publication->Publish(*iter,                            \r\n          boost::bind(&Publisher::OnPublishComplete, this, _1), *pubIter);\r\n      ...\r\n```\r\n\r\nSo I believe the intention is to expect a certain amount of calls to `OnPublishComplete()`. To achieve this, the `this->pubIds` is set with the message ID as key, and as a value the expected number of calls:\r\n\r\n```C++\r\n      ...\r\n      if (result > 0)                                                           \r\n        this->pubIds[*pubIter] = result;                                        \r\n      else                                                                      \r\n        this->pubIds.erase(*pubIter);                                           \r\n    }\r\n    ...\r\n```\r\n\r\nPlease correct me if I have misunderstood this intention.\r\n\r\nThere is a few issues with the above bit of code:\r\n\r\n*  `pubIds` is not mutex protected as it should be.\r\n* If we have only local subscribers, the counter should still be set to 1, because `OnPublishComplete` will still be called once.\r\n* It is possible (randomly due to threads) that by the time `this->pubIds` is set to the value of `result`, `OnPublishComplete()` has already been called, and the entry in `pubIds` has already been erased. This has happened to me, which brought me onto this issue in the first place. In this case, if we have remote subscribers, we will just re-add it here, and **it will never be removed again**! Which will in turn cause all future calls to `SendMessage()` to not do anything, as per condition `!this->pubIds.empty()` in the beginning of the function. So we have a \"publishing dead-end\".\r\n\r\nThe tricky bit is that this only happens when using remote subscribers, which may be a reason why it has gone unnoticed in the automated tests so far? Because if there are only local subscribers, `result` is 0, and the buffer will just always be cleared (it will not really be used actually). So the issue won't arise at all.\r\n\r\nThis PR proposes a way to fix this up, though it's not ready to be merged as there could be better (but more intrusive) solutions to this. I've put it up for discussion. I added some more comments to the code to explain what's going on. \r\n\r\nI've also added a test file which still requires to start a remote publisher manually (by `gz topic -e <topic>`), which is something that should be simulated instead.  \r\nYou can trigger the failure case by commenting `TEMP_NEW_APPROACH_TEST` in Publisher.cc, which will then use the old code. You may have to try a few times because of the randomness, sometimes it can still succeed with the old code.\r\n\r\nOne last thing: It would be important to let the user know that if they are only using \"blocking\" calls to `Publisher::Publish()`, it is *not* guaranteed that the message has actually already been sent. It may still sit in the queue, and it may actually be necessary to call `Publisher::SendMessage()` again to make sure the queue has been emptied. See also comments in the code.", "markup": "markdown", "html": "<p>I believe I stumbled over a bug in the transport system which sometimes stalls the message publishing of a <code>transport::Publisher</code>. This can be triggered when using <code>Publisher::Publish()</code> in blocking mode (parameter _block=true).</p>\n<p>This is a multi-threading related issue which I think should be fixed in any case (also for non-blocking mode).</p>\n<p>It's probably easiest to explain the issue on code snippets of the existing code.</p>\n<p>For easy reference: <code>OnPublishComplete</code> is the function which should be called at the time just after a message has just been sent (which can happen from another thread). It decreases a counter for this message ID, and deletes the entry from the buffer if the counter reaches zero. This basically helps to keep track on the number of times this function was called for each message. <br />\nNote that the <code>this-&gt;pubIds</code> map is protected by <code>this-&gt;mutex</code>.</p>\n<div class=\"codehilite language-C++\"><pre><span></span><span class=\"kt\">void</span> <span class=\"n\">Publisher</span><span class=\"o\">::</span><span class=\"n\">OnPublishComplete</span><span class=\"p\">(</span><span class=\"kt\">uint32_t</span> <span class=\"n\">_id</span><span class=\"p\">)</span> \n<span class=\"p\">{</span> \n <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex</span><span class=\"p\">);</span> \n\n <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">map</span><span class=\"o\">&lt;</span><span class=\"kt\">uint32_t</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;::</span><span class=\"n\">iterator</span> <span class=\"n\">iter</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">_id</span><span class=\"p\">);</span> \n <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">iter</span> <span class=\"o\">!=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"o\">--</span><span class=\"n\">iter</span><span class=\"o\">-&gt;</span><span class=\"n\">second</span><span class=\"p\">)</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> \n <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">erase</span><span class=\"p\">(</span><span class=\"n\">iter</span><span class=\"p\">);</span> \n<span class=\"p\">}</span> \n</pre></div>\n\n\n<p>Then there is the function <code>SendMessage()</code> which is called from <code>Publisher::Publish()</code> when in blocking mode. The blocking is supposed to wait until the message is \"written out\" (<em>minor side issue:</em> this is a phrasing in the comments that could maybe be changed, because the actual \"writing out\" still happens asynchronously from <code>Publication</code>, so a call of <code>Publisher::Publish(..block=true)</code> will not actually guarantee the message has been written out!).</p>\n<div class=\"codehilite language-C++\"><pre><span></span><span class=\"kt\">void</span> <span class=\"n\">Publisher</span><span class=\"o\">::</span><span class=\"n\">SendMessage</span><span class=\"p\">()</span>                                                   \n<span class=\"p\">{</span>                                                                               \n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"n\">MessagePtr</span><span class=\"o\">&gt;</span> <span class=\"n\">localBuffer</span><span class=\"p\">;</span>                                            \n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">uint32_t</span><span class=\"o\">&gt;</span> <span class=\"n\">localIds</span><span class=\"p\">;</span>                                                 \n\n  <span class=\"p\">{</span>                                                                             \n    <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">::</span><span class=\"n\">scoped_lock</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">mutex</span><span class=\"p\">);</span>                                \n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">()</span> <span class=\"o\">||</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span>                        \n      <span class=\"k\">return</span><span class=\"p\">;</span>                                                                   \n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>                    \n    <span class=\"p\">{</span>                                                                           \n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">10000</span><span class=\"p\">;</span>                                  \n      <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">[</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>                                            \n      <span class=\"n\">localIds</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubId</span><span class=\"p\">);</span>                                          \n    <span class=\"p\">}</span>                                                                           \n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">copy</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">(),</span>                     \n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">back_inserter</span><span class=\"p\">(</span><span class=\"n\">localBuffer</span><span class=\"p\">));</span>                                       \n    <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">messages</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">();</span>                                                     \n  <span class=\"p\">}</span>\n  <span class=\"p\">...</span>\n</pre></div>\n\n\n<p>This first part basically has copied everything into local buffers (presumably to avoid blocking the mutex too long and to avoid deadlocks). This is all trivial, except one crucial thing to note here: If there are any message ID's still hanging around in <code>this-&gt;pubID</code>, this function won't do anything more - no \"writing out\" happens. This can be interpreted as <em>\"if there are any messages which have not finished publishing yet, don't proceed, and instead keep them in the <code>this-&gt;messages</code>buffer until the next time SendMessage() is called\"</em>. I guess this was done in order to ensure that messages are sent out in the right order (?).</p>\n<p>Next, the copies of <code>messages</code> and <code>pubIDs</code> are used to actually publish the messages using <code>transport::Publication::Publish()</code>, which will trigger a call to <code>OnPublishComplete()</code> <strong>once for each subscriber callback</strong> of <code>Publication</code>. A subscriber callback however is used for <strong>remote subscribers</strong> only (started in a separate terminal). It's probably possible to add subscriber callbacks in different ways too. But here it's only important that if we have local subscribers (as in all the gtests as far as I can see), we won't have a subscriber callback. <br />\n<em>Bottom line:</em> <code>Publication::Publish()</code> basically returns the number of times the <code>OnPublishComplete()</code> callback has been triggered per remote subscriber (Note that with remote subscribers, the actual calling of OnPublishComplete() happens asynchronously: the subscriber callback <code>SubscriptionTransport::HandleData()</code> only enqueues the message).</p>\n<div class=\"codehilite language-C++\"><pre><span></span>  <span class=\"p\">...</span>\n  <span class=\"c1\">// Only send messages if there is something to send                           </span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">localBuffer</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span>                                                     \n  <span class=\"p\">{</span>                                                                             \n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">uint32_t</span><span class=\"o\">&gt;::</span><span class=\"n\">iterator</span> <span class=\"n\">pubIter</span> <span class=\"o\">=</span> <span class=\"n\">localIds</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>                   \n\n    <span class=\"c1\">// Send all the current messages                                            </span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"n\">MessagePtr</span><span class=\"o\">&gt;::</span><span class=\"n\">iterator</span> <span class=\"n\">iter</span> <span class=\"o\">=</span> <span class=\"n\">localBuffer</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>            \n        <span class=\"n\">iter</span> <span class=\"o\">!=</span> <span class=\"n\">localBuffer</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">iter</span><span class=\"p\">,</span> <span class=\"o\">++</span><span class=\"n\">pubIter</span><span class=\"p\">)</span>                           \n    <span class=\"p\">{</span>                                                                           \n      <span class=\"c1\">// Send the latest message.                                               </span>\n      <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">publication</span><span class=\"o\">-&gt;</span><span class=\"n\">Publish</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">iter</span><span class=\"p\">,</span>                            \n          <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Publisher</span><span class=\"o\">::</span><span class=\"n\">OnPublishComplete</span><span class=\"p\">,</span> <span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"n\">_1</span><span class=\"p\">),</span> <span class=\"o\">*</span><span class=\"n\">pubIter</span><span class=\"p\">);</span>\n      <span class=\"p\">...</span>\n</pre></div>\n\n\n<p>So I believe the intention is to expect a certain amount of calls to <code>OnPublishComplete()</code>. To achieve this, the <code>this-&gt;pubIds</code> is set with the message ID as key, and as a value the expected number of calls:</p>\n<div class=\"codehilite language-C++\"><pre><span></span>      <span class=\"p\">...</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">result</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>                                                           \n        <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">[</span><span class=\"o\">*</span><span class=\"n\">pubIter</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"p\">;</span>                                        \n      <span class=\"k\">else</span>                                                                      \n        <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">pubIds</span><span class=\"p\">.</span><span class=\"n\">erase</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">pubIter</span><span class=\"p\">);</span>                                           \n    <span class=\"p\">}</span>\n    <span class=\"p\">...</span>\n</pre></div>\n\n\n<p>Please correct me if I have misunderstood this intention.</p>\n<p>There is a few issues with the above bit of code:</p>\n<ul>\n<li><code>pubIds</code> is not mutex protected as it should be.</li>\n<li>If we have only local subscribers, the counter should still be set to 1, because <code>OnPublishComplete</code> will still be called once.</li>\n<li>It is possible (randomly due to threads) that by the time <code>this-&gt;pubIds</code> is set to the value of <code>result</code>, <code>OnPublishComplete()</code> has already been called, and the entry in <code>pubIds</code> has already been erased. This has happened to me, which brought me onto this issue in the first place. In this case, if we have remote subscribers, we will just re-add it here, and <strong>it will never be removed again</strong>! Which will in turn cause all future calls to <code>SendMessage()</code> to not do anything, as per condition <code>!this-&gt;pubIds.empty()</code> in the beginning of the function. So we have a \"publishing dead-end\".</li>\n</ul>\n<p>The tricky bit is that this only happens when using remote subscribers, which may be a reason why it has gone unnoticed in the automated tests so far? Because if there are only local subscribers, <code>result</code> is 0, and the buffer will just always be cleared (it will not really be used actually). So the issue won't arise at all.</p>\n<p>This PR proposes a way to fix this up, though it's not ready to be merged as there could be better (but more intrusive) solutions to this. I've put it up for discussion. I added some more comments to the code to explain what's going on. </p>\n<p>I've also added a test file which still requires to start a remote publisher manually (by <code>gz topic -e &lt;topic&gt;</code>), which is something that should be simulated instead.<br />\nYou can trigger the failure case by commenting <code>TEMP_NEW_APPROACH_TEST</code> in Publisher.cc, which will then use the old code. You may have to try a few times because of the randomness, sometimes it can still succeed with the old code.</p>\n<p>One last thing: It would be important to let the user know that if they are only using \"blocking\" calls to <code>Publisher::Publish()</code>, it is <em>not</em> guaranteed that the message has actually already been sent. It may still sit in the queue, and it may actually be necessary to call <code>Publisher::SendMessage()</code> again to make sure the queue has been emptied. See also comments in the code.</p>", "type": "rendered"}, "source": {"commit": {"hash": "f3a62b47f63b", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/JenniferBuehler/gazebo/commit/f3a62b47f63b"}, "html": {"href": "https://bitbucket.org/JenniferBuehler/gazebo/commits/f3a62b47f63b"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/JenniferBuehler/gazebo"}, "html": {"href": "https://bitbucket.org/JenniferBuehler/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{11522dd5-648b-4e9e-b908-d3e1170ba728}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo", "full_name": "JenniferBuehler/gazebo", "uuid": "{11522dd5-648b-4e9e-b908-d3e1170ba728}"}, "branch": {"name": "transport_sendmessage_blocking_issue"}}, "comment_count": 55, "state": "MERGED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2017-08-16T21:44:09.547177+00:00", "type": "participant", "approved": false, "user": {"display_name": "Peter Horak", "uuid": "{c72abe74-c12a-4128-a6fc-94f3844ac8ef}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc72abe74-c12a-4128-a6fc-94f3844ac8ef%7D"}, "html": {"href": "https://bitbucket.org/%7Bc72abe74-c12a-4128-a6fc-94f3844ac8ef%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:451ed60b-3cfa-4a97-b4d3-a3fc34c2b21a/87d803b7-3e50-40c1-8159-a5c20abd84ea/128"}}, "nickname": "pchorak", "type": "user", "account_id": "557058:451ed60b-3cfa-4a97-b4d3-a3fc34c2b21a"}}, {"role": "PARTICIPANT", "participated_on": "2017-07-07T16:24:29.839524+00:00", "type": "participant", "approved": false, "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}}, {"role": "PARTICIPANT", "participated_on": "2018-03-12T19:22:39.487487+00:00", "type": "participant", "approved": true, "user": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}, {"role": "PARTICIPANT", "participated_on": "2018-05-04T05:05:23.614642+00:00", "type": "participant", "approved": false, "user": {"display_name": "Jennifer Buehler", "uuid": "{5949baad-8c43-4d52-9a82-bb8c3511fed8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D"}, "html": {"href": "https://bitbucket.org/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/b28ae0e95eada6ee16f0860c1fa59fdcd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJB-4.png"}}, "nickname": "JenniferBuehler", "type": "user", "account_id": "557058:96bd489a-ec14-4a06-8d31-7bb6d46d1209"}}, {"role": "PARTICIPANT", "participated_on": "2018-05-04T00:55:07.183766+00:00", "type": "participant", "approved": true, "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}}], "reason": "", "updated_on": "2018-05-07T07:27:57.653629+00:00", "author": {"display_name": "Jennifer Buehler", "uuid": "{5949baad-8c43-4d52-9a82-bb8c3511fed8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D"}, "html": {"href": "https://bitbucket.org/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/b28ae0e95eada6ee16f0860c1fa59fdcd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJB-4.png"}}, "nickname": "JenniferBuehler", "type": "user", "account_id": "557058:96bd489a-ec14-4a06-8d31-7bb6d46d1209"}, "merge_commit": {"hash": "562cf6ef3995", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo/commit/562cf6ef3995.json"}, "html": {"href": "#!/osrf/gazebo/commits/562cf6ef3995"}}}, "closed_by": {"display_name": "Steve Peters", "uuid": "{2ccfed09-18b8-4921-8d58-15ef01092802}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D"}, "html": {"href": "https://bitbucket.org/%7B2ccfed09-18b8-4921-8d58-15ef01092802%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/1fb4816dad9e68337d3096f750951f6cd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsSP-1.png"}}, "nickname": "Steven Peters", "type": "user", "account_id": "557058:5de38267-b118-494c-aa76-4fab35448816"}}