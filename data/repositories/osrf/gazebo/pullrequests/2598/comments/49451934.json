{"links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2598/comments/49451934.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2598/_/diff#comment-49451934"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 2598, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2598.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2598"}}, "title": "Fix2111"}, "content": {"raw": "This is certainly a thorny issue, and both views on the matter are understandable.\n\nOn one hand, changing one component of an object's state shouldn't clobber another component of the state unless it's completely necessary in order to preserve sanity, so zeroing out the twist seems like a superfluous behavior in this function.\n\nOn the other hand, it could be argued that having the velocity component of an object's state persist between physics-defying teleportations of an object is not particularly sane (unless we're supporting use cases for Aperture Science portal devices).\n\nTrying to mix together physics-obeying concepts of momentum conservation with physics-defying concepts of discrete teleportation seems like begging for trouble. Since there is no obviously correct behavior in this circumstance, I agree with @zachanderson that the nicest thing to do would be to allow the user to specify the behavior with a flag, and have the default match the legacy behavior. That would mean adding a boolean flag to `MoveFrame` and `SetPosition`.\n\nThe catch with that solution is that `SetPosition` is a virtual function which gets implemented by every single physics engine, potentially multiple times (up to once for each joint type in each physics engine), so this fix would not be as trivial to implement as it seems on the surface. Worse yet, right now the exact behavior of `SetPosition` varies between physics engines, where some will zero out the velocity while others do not. If we introduce a flag which tells the physics engine to zero out the **world** velocity of the joint's child link, this would be extremely problematic for physics engines which use generalized coordinates, like DART and Simbody. That would require them to perform an inverse differential kinematics computation to find a set of parent joint velocities that would achieve zero world velocity for the child link. In many cases, such a solution might not even exist mathematically.\n\nTherefore, while it's not the most user-friendly option, I think the most sensible option is to make the user responsible for saving the world velocity before calling the function and then reverting to that velocity afterwards. We should also add documentation to `MoveFrame` which indicates that it will reset the velocity, and add documentation to `SetPosition` to indicate that its behavior varies between physics engines (specifically that ODE and Bullet resets it while DART and Simbody don't).\n\nThen, in the ROS JointPosition interface, we can tweak its behavior so that it saves the velocity before calling `SetPosition` and then reverts to that velocity after calling the function. I believe that should opaquely solve the problem for the users who have reported being affected in this thread.", "markup": "markdown", "html": "<p>This is certainly a thorny issue, and both views on the matter are understandable.</p>\n<p>On one hand, changing one component of an object's state shouldn't clobber another component of the state unless it's completely necessary in order to preserve sanity, so zeroing out the twist seems like a superfluous behavior in this function.</p>\n<p>On the other hand, it could be argued that having the velocity component of an object's state persist between physics-defying teleportations of an object is not particularly sane (unless we're supporting use cases for Aperture Science portal devices).</p>\n<p>Trying to mix together physics-obeying concepts of momentum conservation with physics-defying concepts of discrete teleportation seems like begging for trouble. Since there is no obviously correct behavior in this circumstance, I agree with @zachanderson that the nicest thing to do would be to allow the user to specify the behavior with a flag, and have the default match the legacy behavior. That would mean adding a boolean flag to <code>MoveFrame</code> and <code>SetPosition</code>.</p>\n<p>The catch with that solution is that <code>SetPosition</code> is a virtual function which gets implemented by every single physics engine, potentially multiple times (up to once for each joint type in each physics engine), so this fix would not be as trivial to implement as it seems on the surface. Worse yet, right now the exact behavior of <code>SetPosition</code> varies between physics engines, where some will zero out the velocity while others do not. If we introduce a flag which tells the physics engine to zero out the <strong>world</strong> velocity of the joint's child link, this would be extremely problematic for physics engines which use generalized coordinates, like DART and Simbody. That would require them to perform an inverse differential kinematics computation to find a set of parent joint velocities that would achieve zero world velocity for the child link. In many cases, such a solution might not even exist mathematically.</p>\n<p>Therefore, while it's not the most user-friendly option, I think the most sensible option is to make the user responsible for saving the world velocity before calling the function and then reverting to that velocity afterwards. We should also add documentation to <code>MoveFrame</code> which indicates that it will reset the velocity, and add documentation to <code>SetPosition</code> to indicate that its behavior varies between physics engines (specifically that ODE and Bullet resets it while DART and Simbody don't).</p>\n<p>Then, in the ROS JointPosition interface, we can tweak its behavior so that it saves the velocity before calling <code>SetPosition</code> and then reverts to that velocity after calling the function. I believe that should opaquely solve the problem for the users who have reported being affected in this thread.</p>", "type": "rendered"}, "created_on": "2017-11-13T19:01:36.567610+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2017-11-13T19:01:36.593897+00:00", "type": "pullrequest_comment", "id": 49451934}