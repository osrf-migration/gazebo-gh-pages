{"links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2657/comments/63338469.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2657/_/diff#comment-63338469"}}, "deleted": false, "pullrequest": {"type": "pullrequest", "id": 2657, "links": {"self": {"href": "data/repositories/osrf/gazebo/pullrequests/2657.json"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2657"}}, "title": "Fixing issue in which publishing of messages gets stuck."}, "content": {"raw": "Thanks for the thorough explanation! This must have been a perplexing issue when you ran into it.\n\nI think I understand the problem, and this proposed fix makes sense, especially protecting the `pubIds` object with a mutex every time that it's being used.\n\nI had to flex my brain quite a bit in order to grok this line: `this->pubIds[*pubIter] = std::max(1, expRemoteCalls);`. In case it's helpful for others, I'll try to explain my understanding of it, and @JenniferBuehler (or anyone else) can correct me if I'm wrong:\n\n* We need to make sure that `this->pubIds[*pubIter]` gets deleted\n* If any remote subscribers exist, they will try to automatically deal with deleting it (in this case, `expRemoteCalls >= 1`)\n    * If none of the remote subscriptions change between `int expRemoteCalls = this->publication->GetCallbackCount();` and `int result = this->publication->Publish(*iter, ...`, then `this->pubIds[*pubIter]` will automatically be deleted by `OnPublishComplete(~)`.\n        * `int diff = result - expRemoteCalls;` will evaluate to zero, so we will skip the block inside of `if(diff < 0)`, which is okay because we don't need it.\n    * If new remote subscribers show up between `int expRemoteCalls = this->publication->GetCallbackCount();` and `int result = this->publication->Publish(*iter, ...`, then the value of `this->pubIds[*pubIter]` will easily decrement below zero and get automatically deleted.\n        * Some newer remote subscribers might miss the message, but that's what they get for showing up late.\n        * `int diff = result - expRemoteCalls;` will evaluate to greater than zero, so we will skip the block inside of `if(diff < 0)`, which is okay because we don't need it.\n    * If some remote subscribers are deleted between `int expRemoteCalls = this->publication->GetCallbackCount();` and `int result = this->publication->Publish(*iter, ...`, then `this->pubIds[*pubIter]` will not automatically be deleted by `OnPublishComplete(~)`\n        * Each time a remote subscriber calls `OnPublishComplete(~)`, it will think that there are still other remote subscribers that need to get the message, so it won't be deleted by `OnPublishComplete(~)`.\n        * `int diff = result - expRemoteCalls;` will evaluate to less than zero, so we will run the block inside of `if(diff < 0)`, because we need to manually delete `this->pubIds[*pubiter]`.\n            * We will reduce `this->pubIds[*pubIter]` by how much our initial expected remote subscriber count was off by.\n            * This is subtracted in a thread-safe way to avoid race conditions.\n            * If all the expected remote subscribers have seen the message (`this->pubIds[*pubIter] <= 0`), we delete it now.\n            * If some of the expected remote subscribers haven't seen the message yet (`this->pubIds[*pubIter] > 0`), allow `OnPublishComplete(~)` to take care of it whenever the count drops all the way\n                * Since we've applied the correction term (`diff`) to `this->pubIds[*pubIter]`, we should now get the correct behavior out of `OnPublishComplete(~)`.\n\n* If no remote subscribers exist, `this->pubIds[*pubIter]` must be deleted in this function (in this case, `expRemoteCalls == 0`)\n    * We will set `expRemoteCalls` to `1`, so that the following control flow works:\n        * If no remote subscriptions were added, `int diff = result - expRemoteCalls;` will evaluate to `-1`, so we will enter `if(diff < 0)` and manually delete `this->pubIds[*pubIter]`\n            * The previous bullet point would not work if we had left `expRemoteCalls` as `0` instead of making it `1`, because it would not have known the difference between the expected number of remote subscribers being the same as the actual (in which case no manual deletion is needed) or there being no remote subscribers at all (in which case, we need to manually delete).\n    * If remote subscriptions were added, `this->pubIds[*pubIter]` will definitely get automatically deleted.\n    * Remote subscriptions could not have been deleted, because there weren't any to begin with.\n\nThere are probably some loose threads and unfortunate edge cases still in this (like messages getting dropped for new subscribers), but I'm confident that these proposed changes at least fix the specific issue that they're intended to address. I think to fix this system any further would require a major design change, which we already have in `ign-transport`, so there's not much sense in doing it for `gazebo/transport`.\n\nIn other words, these changes look good to me.", "markup": "markdown", "html": "<p>Thanks for the thorough explanation! This must have been a perplexing issue when you ran into it.</p>\n<p>I think I understand the problem, and this proposed fix makes sense, especially protecting the <code>pubIds</code> object with a mutex every time that it's being used.</p>\n<p>I had to flex my brain quite a bit in order to grok this line: <code>this-&gt;pubIds[*pubIter] = std::max(1, expRemoteCalls);</code>. In case it's helpful for others, I'll try to explain my understanding of it, and @JenniferBuehler (or anyone else) can correct me if I'm wrong:</p>\n<ul>\n<li>We need to make sure that <code>this-&gt;pubIds[*pubIter]</code> gets deleted</li>\n<li>\n<p>If any remote subscribers exist, they will try to automatically deal with deleting it (in this case, <code>expRemoteCalls &gt;= 1</code>)</p>\n<ul>\n<li>If none of the remote subscriptions change between <code>int expRemoteCalls = this-&gt;publication-&gt;GetCallbackCount();</code> and <code>int result = this-&gt;publication-&gt;Publish(*iter, ...</code>, then <code>this-&gt;pubIds[*pubIter]</code> will automatically be deleted by <code>OnPublishComplete(~)</code>.<ul>\n<li><code>int diff = result - expRemoteCalls;</code> will evaluate to zero, so we will skip the block inside of <code>if(diff &lt; 0)</code>, which is okay because we don't need it.</li>\n</ul>\n</li>\n<li>If new remote subscribers show up between <code>int expRemoteCalls = this-&gt;publication-&gt;GetCallbackCount();</code> and <code>int result = this-&gt;publication-&gt;Publish(*iter, ...</code>, then the value of <code>this-&gt;pubIds[*pubIter]</code> will easily decrement below zero and get automatically deleted.<ul>\n<li>Some newer remote subscribers might miss the message, but that's what they get for showing up late.</li>\n<li><code>int diff = result - expRemoteCalls;</code> will evaluate to greater than zero, so we will skip the block inside of <code>if(diff &lt; 0)</code>, which is okay because we don't need it.</li>\n</ul>\n</li>\n<li>If some remote subscribers are deleted between <code>int expRemoteCalls = this-&gt;publication-&gt;GetCallbackCount();</code> and <code>int result = this-&gt;publication-&gt;Publish(*iter, ...</code>, then <code>this-&gt;pubIds[*pubIter]</code> will not automatically be deleted by <code>OnPublishComplete(~)</code><ul>\n<li>Each time a remote subscriber calls <code>OnPublishComplete(~)</code>, it will think that there are still other remote subscribers that need to get the message, so it won't be deleted by <code>OnPublishComplete(~)</code>.</li>\n<li><code>int diff = result - expRemoteCalls;</code> will evaluate to less than zero, so we will run the block inside of <code>if(diff &lt; 0)</code>, because we need to manually delete <code>this-&gt;pubIds[*pubiter]</code>.<ul>\n<li>We will reduce <code>this-&gt;pubIds[*pubIter]</code> by how much our initial expected remote subscriber count was off by.</li>\n<li>This is subtracted in a thread-safe way to avoid race conditions.</li>\n<li>If all the expected remote subscribers have seen the message (<code>this-&gt;pubIds[*pubIter] &lt;= 0</code>), we delete it now.</li>\n<li>If some of the expected remote subscribers haven't seen the message yet (<code>this-&gt;pubIds[*pubIter] &gt; 0</code>), allow <code>OnPublishComplete(~)</code> to take care of it whenever the count drops all the way<ul>\n<li>Since we've applied the correction term (<code>diff</code>) to <code>this-&gt;pubIds[*pubIter]</code>, we should now get the correct behavior out of <code>OnPublishComplete(~)</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>If no remote subscribers exist, <code>this-&gt;pubIds[*pubIter]</code> must be deleted in this function (in this case, <code>expRemoteCalls == 0</code>)</p>\n<ul>\n<li>We will set <code>expRemoteCalls</code> to <code>1</code>, so that the following control flow works:<ul>\n<li>If no remote subscriptions were added, <code>int diff = result - expRemoteCalls;</code> will evaluate to <code>-1</code>, so we will enter <code>if(diff &lt; 0)</code> and manually delete <code>this-&gt;pubIds[*pubIter]</code><ul>\n<li>The previous bullet point would not work if we had left <code>expRemoteCalls</code> as <code>0</code> instead of making it <code>1</code>, because it would not have known the difference between the expected number of remote subscribers being the same as the actual (in which case no manual deletion is needed) or there being no remote subscribers at all (in which case, we need to manually delete).</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>If remote subscriptions were added, <code>this-&gt;pubIds[*pubIter]</code> will definitely get automatically deleted.</li>\n<li>Remote subscriptions could not have been deleted, because there weren't any to begin with.</li>\n</ul>\n</li>\n</ul>\n<p>There are probably some loose threads and unfortunate edge cases still in this (like messages getting dropped for new subscribers), but I'm confident that these proposed changes at least fix the specific issue that they're intended to address. I think to fix this system any further would require a major design change, which we already have in <code>ign-transport</code>, so there's not much sense in doing it for <code>gazebo/transport</code>.</p>\n<p>In other words, these changes look good to me.</p>", "type": "rendered"}, "created_on": "2018-05-04T00:55:01.590243+00:00", "user": {"display_name": "Michael Grey", "uuid": "{c1cdfe52-2887-474c-ae99-72fdc53a59c9}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D"}, "html": {"href": "https://bitbucket.org/%7Bc1cdfe52-2887-474c-ae99-72fdc53a59c9%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:67759e29-d1df-465f-868d-047738e36fc9/d42d74cf-c1bd-4431-8288-07f543bbe325/128"}}, "nickname": "mxgrey", "type": "user", "account_id": "557058:67759e29-d1df-465f-868d-047738e36fc9"}, "updated_on": "2018-05-04T00:55:01.637956+00:00", "type": "pullrequest_comment", "id": 63338469}