{"rendered": {"reason": {"raw": "Closed because outdated.", "markup": "markdown", "html": "<p>Closed because outdated.</p>", "type": "rendered"}, "description": {"raw": "While I was running tests to compare the states of two worlds I noticed two member variables in physics::Link which are never really used anywhere: *linearAccel* and *angularAccel*.\r\n\r\nTo explain how I found this and to reproduce the state comparison failure:\r\n\r\n- get the LinkState of one Link, e.g. ``LinkState s(yourLink);``\r\n- set another Link to the same state, i.e. ``otherLink->SetState(s); ``\r\n- get the new state of the second link, i.e. ``LinkState s2(otherLink);`` - both links should now have the same state.\r\n- compare the states ``s1`` and ``s2`` see that accelerations are *not* the same.\r\n\r\nReason why they are not: The LinkState is created from the states of Link::WorldLinearVel(), Link::WorldLinearAccel() etc., so from the states in *world frame* (see LinkState.cc constructor). However when the link is set to a specific state in Link::SetState, it uses Link::SetLinearAccel and Link::SetAngularAccel, which simply write the values in the member variables *linearAccel* and *angularAccel*. However... *those values are never read anywhere again*, in the whole code base. This is maybe a remnant of old times?\r\n\r\nI removed all functions related to setting accelerations and compiled/tested, which confirmed that the functions were actually never called from anywhere. Another reason for the removal is that setting accelerations explicitly from the Link interface doesn't make sense, this is something the physics engine determines. When an acceleration is to be applied to a body, a *force* should be used instead - this then determines acceleration in the next update step, and the resulting acceleration may (though in the ideal world should not) differ between engines.\r\nI am wondering whether this is also why setting the acceleration is not supported by any of the physics engine's Link subclasses (and which is why Link's SetLinear/AngularAccel is not virtual).\r\n\r\nOne remaining issue with the accelerations is that setting the state of a Link from LinkState will now just skip the acceleration value. But this never was working anyway: as it was, it was just setting the unused member variables; acceleration was always determined by the physics engines.\r\n\r\n**Additional suggestion**\r\n\r\nI would also like to suggest the following trivial changes to the interface, though I haven't included it in this PR yet:\r\nWould it maybe be better to rename functions\r\n\r\n* Link::SetLinearVel\r\n* Link::SetAngularVel\r\n* Link::SetForce and\r\n* Link::SetTorque\r\n\r\nto the following: \r\n\r\n* Link::SetWorldLinearVel\r\n* Link::SetWorldAngularVel\r\n* Link::SetWorldForce and\r\n* Link::SetWorldTorque.\r\n\r\nThis way they match with the getter names (e.g. Link::WorldLinearVel()) which further avoids confusion. From looking at the physics engine's Link implementations, that's what the methods are intended to do anyway: set the world velocity, not the relative velocity.", "markup": "markdown", "html": "<p>While I was running tests to compare the states of two worlds I noticed two member variables in physics::Link which are never really used anywhere: <em>linearAccel</em> and <em>angularAccel</em>.</p>\n<p>To explain how I found this and to reproduce the state comparison failure:</p>\n<ul>\n<li>get the LinkState of one Link, e.g. <code>LinkState s(yourLink);</code></li>\n<li>set another Link to the same state, i.e. <code>otherLink-&gt;SetState(s);</code></li>\n<li>get the new state of the second link, i.e. <code>LinkState s2(otherLink);</code> - both links should now have the same state.</li>\n<li>compare the states <code>s1</code> and <code>s2</code> see that accelerations are <em>not</em> the same.</li>\n</ul>\n<p>Reason why they are not: The LinkState is created from the states of Link::WorldLinearVel(), Link::WorldLinearAccel() etc., so from the states in <em>world frame</em> (see LinkState.cc constructor). However when the link is set to a specific state in Link::SetState, it uses Link::SetLinearAccel and Link::SetAngularAccel, which simply write the values in the member variables <em>linearAccel</em> and <em>angularAccel</em>. However... <em>those values are never read anywhere again</em>, in the whole code base. This is maybe a remnant of old times?</p>\n<p>I removed all functions related to setting accelerations and compiled/tested, which confirmed that the functions were actually never called from anywhere. Another reason for the removal is that setting accelerations explicitly from the Link interface doesn't make sense, this is something the physics engine determines. When an acceleration is to be applied to a body, a <em>force</em> should be used instead - this then determines acceleration in the next update step, and the resulting acceleration may (though in the ideal world should not) differ between engines.\nI am wondering whether this is also why setting the acceleration is not supported by any of the physics engine's Link subclasses (and which is why Link's SetLinear/AngularAccel is not virtual).</p>\n<p>One remaining issue with the accelerations is that setting the state of a Link from LinkState will now just skip the acceleration value. But this never was working anyway: as it was, it was just setting the unused member variables; acceleration was always determined by the physics engines.</p>\n<p><strong>Additional suggestion</strong></p>\n<p>I would also like to suggest the following trivial changes to the interface, though I haven't included it in this PR yet:\nWould it maybe be better to rename functions</p>\n<ul>\n<li>Link::SetLinearVel</li>\n<li>Link::SetAngularVel</li>\n<li>Link::SetForce and</li>\n<li>Link::SetTorque</li>\n</ul>\n<p>to the following: </p>\n<ul>\n<li>Link::SetWorldLinearVel</li>\n<li>Link::SetWorldAngularVel</li>\n<li>Link::SetWorldForce and</li>\n<li>Link::SetWorldTorque.</li>\n</ul>\n<p>This way they match with the getter names (e.g. Link::WorldLinearVel()) which further avoids confusion. From looking at the physics engine's Link implementations, that's what the methods are intended to do anyway: set the world velocity, not the relative velocity.</p>", "type": "rendered"}, "title": {"raw": "Remove two members in Link that are never really used and are confusing", "markup": "markdown", "html": "<p>Remove two members in Link that are never really used and are confusing</p>", "type": "rendered"}}, "type": "pullrequest", "description": "While I was running tests to compare the states of two worlds I noticed two member variables in physics::Link which are never really used anywhere: *linearAccel* and *angularAccel*.\r\n\r\nTo explain how I found this and to reproduce the state comparison failure:\r\n\r\n- get the LinkState of one Link, e.g. ``LinkState s(yourLink);``\r\n- set another Link to the same state, i.e. ``otherLink->SetState(s); ``\r\n- get the new state of the second link, i.e. ``LinkState s2(otherLink);`` - both links should now have the same state.\r\n- compare the states ``s1`` and ``s2`` see that accelerations are *not* the same.\r\n\r\nReason why they are not: The LinkState is created from the states of Link::WorldLinearVel(), Link::WorldLinearAccel() etc., so from the states in *world frame* (see LinkState.cc constructor). However when the link is set to a specific state in Link::SetState, it uses Link::SetLinearAccel and Link::SetAngularAccel, which simply write the values in the member variables *linearAccel* and *angularAccel*. However... *those values are never read anywhere again*, in the whole code base. This is maybe a remnant of old times?\r\n\r\nI removed all functions related to setting accelerations and compiled/tested, which confirmed that the functions were actually never called from anywhere. Another reason for the removal is that setting accelerations explicitly from the Link interface doesn't make sense, this is something the physics engine determines. When an acceleration is to be applied to a body, a *force* should be used instead - this then determines acceleration in the next update step, and the resulting acceleration may (though in the ideal world should not) differ between engines.\r\nI am wondering whether this is also why setting the acceleration is not supported by any of the physics engine's Link subclasses (and which is why Link's SetLinear/AngularAccel is not virtual).\r\n\r\nOne remaining issue with the accelerations is that setting the state of a Link from LinkState will now just skip the acceleration value. But this never was working anyway: as it was, it was just setting the unused member variables; acceleration was always determined by the physics engines.\r\n\r\n**Additional suggestion**\r\n\r\nI would also like to suggest the following trivial changes to the interface, though I haven't included it in this PR yet:\r\nWould it maybe be better to rename functions\r\n\r\n* Link::SetLinearVel\r\n* Link::SetAngularVel\r\n* Link::SetForce and\r\n* Link::SetTorque\r\n\r\nto the following: \r\n\r\n* Link::SetWorldLinearVel\r\n* Link::SetWorldAngularVel\r\n* Link::SetWorldForce and\r\n* Link::SetWorldTorque.\r\n\r\nThis way they match with the getter names (e.g. Link::WorldLinearVel()) which further avoids confusion. From looking at the physics engine's Link implementations, that's what the methods are intended to do anyway: set the world velocity, not the relative velocity.", "links": {"decline": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/pullrequests/2617/decline"}, "diffstat": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/diffstat/JenniferBuehler/gazebo:546dc906079c%0D0d39ebf2b92b?from_pullrequest_id=2617"}, "commits": {"href": "data/repositories/osrf/gazebo/pullrequests/2617/commits.json"}, "self": {"href": "data/repositories/osrf/gazebo/pullrequests/2617.json"}, "comments": {"href": "data/repositories/osrf/gazebo/pullrequests/2617/comments_page=1.json"}, "merge": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/pullrequests/2617/merge"}, "html": {"href": "#!/osrf/gazebo/pull-requests/2617"}, "activity": {"href": "data/repositories/osrf/gazebo/pullrequests/2617/activity.json"}, "diff": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/diff/JenniferBuehler/gazebo:546dc906079c%0D0d39ebf2b92b?from_pullrequest_id=2617"}, "approve": {"href": "https://api.bitbucket.org/2.0/repositories/osrf/gazebo/pullrequests/2617/approve"}, "statuses": {"href": "data/repositories/osrf/gazebo/pullrequests/2617/statuses_page=1.json"}}, "title": "Remove two members in Link that are never really used and are confusing", "close_source_branch": false, "reviewers": [], "id": 2617, "destination": {"commit": {"hash": "0d39ebf2b92b", "type": "commit", "links": {"self": {"href": "data/repositories/osrf/gazebo/commit/0d39ebf2b92b.json"}, "html": {"href": "#!/osrf/gazebo/commits/0d39ebf2b92b"}}}, "repository": {"links": {"self": {"href": "data/repositories/osrf/gazebo.json"}, "html": {"href": "#!/osrf/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}ts=1694483"}}, "type": "repository", "name": "gazebo", "full_name": "osrf/gazebo", "uuid": "{51a0cd5d-8697-4eb1-8b08-e919ee881e1c}"}, "branch": {"name": "default"}}, "created_on": "2017-01-19T06:29:30.190133+00:00", "summary": {"raw": "While I was running tests to compare the states of two worlds I noticed two member variables in physics::Link which are never really used anywhere: *linearAccel* and *angularAccel*.\r\n\r\nTo explain how I found this and to reproduce the state comparison failure:\r\n\r\n- get the LinkState of one Link, e.g. ``LinkState s(yourLink);``\r\n- set another Link to the same state, i.e. ``otherLink->SetState(s); ``\r\n- get the new state of the second link, i.e. ``LinkState s2(otherLink);`` - both links should now have the same state.\r\n- compare the states ``s1`` and ``s2`` see that accelerations are *not* the same.\r\n\r\nReason why they are not: The LinkState is created from the states of Link::WorldLinearVel(), Link::WorldLinearAccel() etc., so from the states in *world frame* (see LinkState.cc constructor). However when the link is set to a specific state in Link::SetState, it uses Link::SetLinearAccel and Link::SetAngularAccel, which simply write the values in the member variables *linearAccel* and *angularAccel*. However... *those values are never read anywhere again*, in the whole code base. This is maybe a remnant of old times?\r\n\r\nI removed all functions related to setting accelerations and compiled/tested, which confirmed that the functions were actually never called from anywhere. Another reason for the removal is that setting accelerations explicitly from the Link interface doesn't make sense, this is something the physics engine determines. When an acceleration is to be applied to a body, a *force* should be used instead - this then determines acceleration in the next update step, and the resulting acceleration may (though in the ideal world should not) differ between engines.\r\nI am wondering whether this is also why setting the acceleration is not supported by any of the physics engine's Link subclasses (and which is why Link's SetLinear/AngularAccel is not virtual).\r\n\r\nOne remaining issue with the accelerations is that setting the state of a Link from LinkState will now just skip the acceleration value. But this never was working anyway: as it was, it was just setting the unused member variables; acceleration was always determined by the physics engines.\r\n\r\n**Additional suggestion**\r\n\r\nI would also like to suggest the following trivial changes to the interface, though I haven't included it in this PR yet:\r\nWould it maybe be better to rename functions\r\n\r\n* Link::SetLinearVel\r\n* Link::SetAngularVel\r\n* Link::SetForce and\r\n* Link::SetTorque\r\n\r\nto the following: \r\n\r\n* Link::SetWorldLinearVel\r\n* Link::SetWorldAngularVel\r\n* Link::SetWorldForce and\r\n* Link::SetWorldTorque.\r\n\r\nThis way they match with the getter names (e.g. Link::WorldLinearVel()) which further avoids confusion. From looking at the physics engine's Link implementations, that's what the methods are intended to do anyway: set the world velocity, not the relative velocity.", "markup": "markdown", "html": "<p>While I was running tests to compare the states of two worlds I noticed two member variables in physics::Link which are never really used anywhere: <em>linearAccel</em> and <em>angularAccel</em>.</p>\n<p>To explain how I found this and to reproduce the state comparison failure:</p>\n<ul>\n<li>get the LinkState of one Link, e.g. <code>LinkState s(yourLink);</code></li>\n<li>set another Link to the same state, i.e. <code>otherLink-&gt;SetState(s);</code></li>\n<li>get the new state of the second link, i.e. <code>LinkState s2(otherLink);</code> - both links should now have the same state.</li>\n<li>compare the states <code>s1</code> and <code>s2</code> see that accelerations are <em>not</em> the same.</li>\n</ul>\n<p>Reason why they are not: The LinkState is created from the states of Link::WorldLinearVel(), Link::WorldLinearAccel() etc., so from the states in <em>world frame</em> (see LinkState.cc constructor). However when the link is set to a specific state in Link::SetState, it uses Link::SetLinearAccel and Link::SetAngularAccel, which simply write the values in the member variables <em>linearAccel</em> and <em>angularAccel</em>. However... <em>those values are never read anywhere again</em>, in the whole code base. This is maybe a remnant of old times?</p>\n<p>I removed all functions related to setting accelerations and compiled/tested, which confirmed that the functions were actually never called from anywhere. Another reason for the removal is that setting accelerations explicitly from the Link interface doesn't make sense, this is something the physics engine determines. When an acceleration is to be applied to a body, a <em>force</em> should be used instead - this then determines acceleration in the next update step, and the resulting acceleration may (though in the ideal world should not) differ between engines.\nI am wondering whether this is also why setting the acceleration is not supported by any of the physics engine's Link subclasses (and which is why Link's SetLinear/AngularAccel is not virtual).</p>\n<p>One remaining issue with the accelerations is that setting the state of a Link from LinkState will now just skip the acceleration value. But this never was working anyway: as it was, it was just setting the unused member variables; acceleration was always determined by the physics engines.</p>\n<p><strong>Additional suggestion</strong></p>\n<p>I would also like to suggest the following trivial changes to the interface, though I haven't included it in this PR yet:\nWould it maybe be better to rename functions</p>\n<ul>\n<li>Link::SetLinearVel</li>\n<li>Link::SetAngularVel</li>\n<li>Link::SetForce and</li>\n<li>Link::SetTorque</li>\n</ul>\n<p>to the following: </p>\n<ul>\n<li>Link::SetWorldLinearVel</li>\n<li>Link::SetWorldAngularVel</li>\n<li>Link::SetWorldForce and</li>\n<li>Link::SetWorldTorque.</li>\n</ul>\n<p>This way they match with the getter names (e.g. Link::WorldLinearVel()) which further avoids confusion. From looking at the physics engine's Link implementations, that's what the methods are intended to do anyway: set the world velocity, not the relative velocity.</p>", "type": "rendered"}, "source": {"commit": {"hash": "546dc906079c", "type": "commit", "links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/JenniferBuehler/gazebo/commit/546dc906079c"}, "html": {"href": "https://bitbucket.org/JenniferBuehler/gazebo/commits/546dc906079c"}}}, "repository": {"links": {"self": {"href": "https://api.bitbucket.org/2.0/repositories/JenniferBuehler/gazebo"}, "html": {"href": "https://bitbucket.org/JenniferBuehler/gazebo"}, "avatar": {"href": "data/bytebucket.org/ravatar/{11522dd5-648b-4e9e-b908-d3e1170ba728}ts=c_plus_plus"}}, "type": "repository", "name": "gazebo", "full_name": "JenniferBuehler/gazebo", "uuid": "{11522dd5-648b-4e9e-b908-d3e1170ba728}"}, "branch": {"name": "remove_superfluous_link_acceleration_velocity"}}, "comment_count": 14, "state": "DECLINED", "task_count": 0, "participants": [{"role": "PARTICIPANT", "participated_on": "2017-01-20T21:51:06.917111+00:00", "type": "participant", "approved": false, "user": {"display_name": "Shane Loretz", "uuid": "{656e3311-aad9-45a1-aaf7-b0ee0e84b287}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D"}, "html": {"href": "https://bitbucket.org/%7B656e3311-aad9-45a1-aaf7-b0ee0e84b287%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:684383ab-ac95-4859-a350-4a6f41a94a22/c7a1ebf5-cade-4115-9f26-9d3facb776db/128"}}, "nickname": "Shane Loretz", "type": "user", "account_id": "557058:684383ab-ac95-4859-a350-4a6f41a94a22"}}, {"role": "PARTICIPANT", "participated_on": "2017-03-23T23:08:54.907077+00:00", "type": "participant", "approved": false, "user": {"display_name": "Louise Poubel", "uuid": "{5cfa2075-477b-4ded-bdb9-8d2479544ec4}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D"}, "html": {"href": "https://bitbucket.org/%7B5cfa2075-477b-4ded-bdb9-8d2479544ec4%7D/"}, "avatar": {"href": "https://avatar-management--avatars.us-west-2.prod.public.atl-paas.net/557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8/7d903d90-c5ea-4182-b7ef-0d467e9e1c74/128"}}, "nickname": "chapulina", "type": "user", "account_id": "557058:6ff86fcb-b7ab-44a5-b8a6-f6d9cae8b6e8"}}, {"role": "PARTICIPANT", "participated_on": "2017-03-27T06:28:57.377963+00:00", "type": "participant", "approved": false, "user": {"display_name": "Jennifer Buehler", "uuid": "{5949baad-8c43-4d52-9a82-bb8c3511fed8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D"}, "html": {"href": "https://bitbucket.org/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/b28ae0e95eada6ee16f0860c1fa59fdcd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJB-4.png"}}, "nickname": "JenniferBuehler", "type": "user", "account_id": "557058:96bd489a-ec14-4a06-8d31-7bb6d46d1209"}}], "reason": "Closed because outdated.", "updated_on": "2017-03-27T06:29:17.866099+00:00", "author": {"display_name": "Jennifer Buehler", "uuid": "{5949baad-8c43-4d52-9a82-bb8c3511fed8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D"}, "html": {"href": "https://bitbucket.org/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/b28ae0e95eada6ee16f0860c1fa59fdcd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJB-4.png"}}, "nickname": "JenniferBuehler", "type": "user", "account_id": "557058:96bd489a-ec14-4a06-8d31-7bb6d46d1209"}, "merge_commit": null, "closed_by": {"display_name": "Jennifer Buehler", "uuid": "{5949baad-8c43-4d52-9a82-bb8c3511fed8}", "links": {"self": {"href": "https://api.bitbucket.org/2.0/users/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D"}, "html": {"href": "https://bitbucket.org/%7B5949baad-8c43-4d52-9a82-bb8c3511fed8%7D/"}, "avatar": {"href": "data/secure.gravatar.com/avatar/b28ae0e95eada6ee16f0860c1fa59fdcd=httpsavatar-management--avatars.us-west-2.prod.public.atl-paas.netinitialsJB-4.png"}}, "nickname": "JenniferBuehler", "type": "user", "account_id": "557058:96bd489a-ec14-4a06-8d31-7bb6d46d1209"}}